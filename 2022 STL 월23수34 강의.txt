파일 이름 : stl.cpp, 파일 크기 : 1860
저장 시간 : 2022-03-02 13:16:36 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 2 수34						월23 수34				(1주 1일)
// 
// - 강의소개 (책, cppreference.com)
// - 코딩 스타일 -> Google c++ style guide 참고
// - 컴파일 환경 세팅 - Release, x64   (시험에도 명시해둘 예정)
// 	 			      - 메뉴, 프로젝트 - 속성 - 최신 C++ 초안의 기능
// - save 파일 작성 (한학기 강의 내용을 자동저장 한다)
// 
// 공부해야 할 내용 - 파일 입출력(텍스트/바이너리 모드)
//-----------------------------------------------------------------------------


#include <iostream>
#include <string_view>
#include <fstream>
#include <filesystem>
#include <vector>
#include <iterator>
#include <chrono>
#include <algorithm>

// 코딩할 내용 - "stl.cpp" 를 읽어 강의저장 파일에 덧붙인다.

void save( std::string_view );

int main()
{
	//std::cout << "string의 크기 - " << sizeof(std::string) << std::endl;
	//std::cout << "string_view의 크기 - " << sizeof(std::string_view) << std::endl;

	save("stl.cpp");
}

void save(std::string_view file_name) 
{
	// 현재 시간을 화면에 출력한다.
	auto time = floor<std::chrono::seconds>(std::chrono::system_clock::now());

	// 읽을 파일을 연다.
	std::ifstream in{ file_name.data() };

	// 저장할 파일도 덧붙이기 모드로 연다.
	std::ofstream out{ "2022 STL 월23수34 강의.txt", std::ios::app };

	// 저장할 파일의 크기와 현재 시간을 파일에 기록한다.
	out << "파일 이름 : " << file_name  << ", 파일 크기 : " << std::filesystem::file_size(file_name) << std::endl;
	out << "저장 시간 : " << std::chrono::zoned_time("Asia/Seoul", time) << std::endl;
	out << std::endl;

	// 벡터를 만들면서 in 파일의 내용을 다 읽어온다.
	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };

	// 벡터로 읽어온 파일을 출력 파일로 내보낸다.
	
	copy(v.begin(), v.end(), std::ostream_iterator<char>{out});

}
파일 이름 : stl.cpp, 파일 크기 : 554
저장 시간 : 2022-03-07 10:39:05 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 2 수34						월23 수34				(1주 1일)
// 
// save 함수를 분리하자
//-----------------------------------------------------------------------------

#include "save.h"

// 코딩할 내용 - "stl.cpp" 를 읽어 강의저장 파일에 덧붙인다.

void save( std::string_view );

int main()
{
	//std::cout << "string의 크기 - " << sizeof(std::string) << std::endl;
	//std::cout << "string_view의 크기 - " << sizeof(std::string_view) << std::endl;

	save("stl.cpp");
}파일 이름 : stl.cpp, 파일 크기 : 575
저장 시간 : 2022-03-07 10:40:07 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 2 수34						월23 수34				(1주 1일)
// 
// save 함수를 분리하자
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"

// 코딩할 내용 - "stl.cpp" 를 읽어 강의저장 파일에 덧붙인다.

void save( std::string_view );

int main()
{
	//std::cout << "string의 크기 - " << sizeof(std::string) << std::endl;
	//std::cout << "string_view의 크기 - " << sizeof(std::string_view) << std::endl;

	save("stl.cpp");
}
파일 이름 : stl.cpp, 파일 크기 : 432
저장 시간 : 2022-03-07 10:47:19 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 7 월23						월23 수34				(1주 2일)
// 
// 할 일 - save 함수를 분리하자
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"

// 코딩할 내용 - "stl.cpp" 를 읽어 강의저장 파일에 덧붙인다.

void save( std::string_view );

int main()
{

	save("stl.cpp");
}

// [문제] main의 코드를 변경하면 안된다
// a와 b의 값이 바뀌어야 한다.

void change(int &a, int &b)
{
	int temp{ a };
	a = b;
	b = temp;
}


int main()
{
	int a{ 1 };
	int b{ 2 };

	change(a, b);
	std::cout << a << ", " << b << std::endl;

	//save("save.cpp");
}


#include <iostream>
//#include "save.h"

// [문제] main의 코드를 변경하면 안된다
// a와 b의 값이 바뀌어야 한다.

class Dog
{
public:
	Dog(int num) : number(num) {}
	~Dog() {}

	int getNumber() { return number; }
	void setNumber(int num) { number = num; }


	friend std::ostream& operator<<(std::ostream& out, const Dog& A) {
		out << A.number;
		return out;
	}
		
private:
	int number;
};


void change(Dog &a, Dog &b)
{
	Dog temp{ a.getNumber() };
	a.setNumber(b.getNumber());
	b.setNumber(temp.getNumber());
}


int main()
{
	Dog a{ 1 };
	Dog b{ 2 };

	change(a, b);
	std::cout << a << ", " << b << std::endl;

	//save("save.cpp");
}


#include <iostream>
//#include "save.h"

// [문제] main의 코드를 변경하면 안된다
// a와 b의 값이 바뀌어야 한다.

class Dog{
public:
	Dog(int num) : number{ num } {}

	friend std::ostream& operator<<(std::ostream&, const Dog&);
private:
	int number;
};

std::ostream& operator<<(std::ostream& out, const Dog& A) {
	out << A.number;
	return out;
}


void change(Dog &a, Dog &b)
{
	Dog temp{ a };
	a = b; // a.operator=(b);
	b = temp;
}


int main()
{
	Dog a{ 1 };
	Dog b{ 2 };

	change(a, b);
	std::cout << a << ", " << b << std::endl;

	//save("save.cpp");
}

파일 이름 : stl.cpp, 파일 크기 : 765
저장 시간 : 2022-03-08 23:17:28 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 7 월23						월23 수34				(1주 2일)
// 
// C++ 복습 - &, class Dog
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <string_view>
#include "save.h"

//[문제] 다음 main을 수정없이 실행되는 템플릿 함수를 작성하라

template<class T>
void change(T &a, T &b)
{
	T temp{ a };
	a = b;
	b = temp;
}

class Dog {
public:
	Dog(std::string, int) {}
private:

};

int main()
{
	/*
	int a{ 1 }, b{ 2 };
	change(a, b);

	std::string c = "STL"s;
	std::string d = "C++"s;
	change(c, d);

	Dog e{ "코코"s, 3 };
	Dog f{ "댕댕이"s, 2 };
	change(e, f);
	*/

	save("stl.cpp");
}

파일 이름 : stl.cpp, 파일 크기 : 1177
저장 시간 : 2022-03-08 23:52:27 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 8 월23						월23 수34				(1주 2일)
// 
// C++ 복습 - &, class Dog
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <string_view>
#include "save.h"

//[문제] 다음 main을 수정없이 실행되는 템플릿 함수를 작성하라

template<typename T>
void change(T& a, T& b)
{
	T temp{ a };
	a = b;
	b = temp;
}

class Dog {
public:
	Dog(std::string str, int num) : name{ str }, age{ num } {}
	

	friend std::ostream& operator<<(std::ostream& , const Dog&);
private:
	std::string name;
	int age;
};

std::ostream& operator<<(std::ostream& os, const Dog& dog)
{
	os << "이름 : " << dog.name << ",  나이 : " << dog.age << std::endl;
	return os;
}

int main()
{
	
	int a{ 1 }, b{ 2 };
	change(a, b);

	std::cout << a << ", " << b << std::endl;

	std::string c = "STL";
	std::string d = "C++ Programming";
	change(c, d);

	std::cout << c << ", " << d << std::endl;

	Dog e{ "코코", 3 };
	Dog f{ "댕댕이", 2 };
	change(e, f);
	
	std::cout << e << f << std::endl;

	save("stl.cpp");
}
파일 이름 : stl.cpp, 파일 크기 : 686
저장 시간 : 2022-03-14 10:43:16 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 14 월23						월23 수34				(2주 1일)
// 
// 
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <string_view>
#include "save.h"

//[문제] 다음 main을 수정없이 실행되는 템플릿 함수를 작성하라

template<typename T>
void change(T& a, T& b)
{
	T temp{ a };
	a = b;
	b = temp;
}

int main()
{
	
	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << ", " << b << std::endl;
	}
	{
		std::string a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << ", " << b << std::endl;
	}

	save("stl.cpp");
}
파일 이름 : stl.cpp, 파일 크기 : 782
저장 시간 : 2022-03-14 10:51:29 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 14 월23						월23 수34				(2주 1일)
// 
// 지난주 복습
//-----------------------------------------------------------------------------

#include <iostream>
#include <string_view>
#include "save.h"

//[문제] 다음 main을 수정없이 실행되는 템플릿 함수를 작성하라

template<typename T>
void change(T& a, T& b)
{
	T temp{ a };
	a = b;
	b = temp;
}

int main()
{
	
	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << ", " << b << std::endl;
	}
	{
		using namespace std::literals;
		// 스트링 리터럴 정의를 위한 네임스페이스 사용
		std::string a{ "1"s }, b{ "2"s };
		change(a, b);
		std::cout << a << ", " << b << std::endl;
	}

	save("stl.cpp");
}
파일 이름 : stl.cpp, 파일 크기 : 1309
저장 시간 : 2022-03-14 11:06:04 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 14 월23						월23 수34				(2주 1일)
// 
// 지난주 복습
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"

//[문제] 다음 main을 수정없이 실행되는 템플릿 함수를 작성하라

template <typename T>
void change(T& a, T& b)
{
	T temp{ a };
	a = b;
	b = temp;
}

// 컴파일러는 함수를 읽어들여 위의 template를 만나면 해당 자료형에 맞게 아래처럼
// 함수를 찍어낸다
// 컴파일러의 과정  1. 함수 찍어내기(template), 2. 기계어 변환
//  -> 아래처럼 함수를 먼저 찍어내고 기계어 변환시 오류를 검사함
template <>
void change(int& a, int& b)
{
	std::cout << "템플릿의 특수화" << std::endl;
	int temp{ a };
	a = b;
	b = temp;
}

template <>
void change(std::string& a, std::string& b)
{
	std::cout << "템플릿의 특수화" << std::endl;
	std::string temp{ a };
	a = b;
	b = temp;
}

// -------
int main()
// -------
{
	
	{
		int a{ 1 }, b{ 2 };
		change(a, b);
		std::cout << a << ", " << b << std::endl;
	}
	{
		using namespace std::literals;
		// 스트링 리터럴 정의를 위한 네임스페이스 사용
		std::string a{ "1"s }, b{ "2"s };
		change(a, b);
		std::cout << a << ", " << b << std::endl;
	}

	save("stl.cpp");
}
파일 이름 : stl.cpp, 파일 크기 : 795
저장 시간 : 2022-03-14 11:19:18 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 14 월23						월23 수34				(2주 1일)
// 
// C++ 설명
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"

/*
C++ Programming language
C++ Programming Paradigm 5가지
1. Procedural PL
	-> 절차적 언어
2. Object Oriented PL
	-> 객체 지향 언어
3. Generic PL(STL)
	-> 자료형의 관계없이 template을 이용하여 해결 -> 문제해결 방법( 컨테이너, 알고리즘 )
4. Template Meta PL
	-> template를 통해 컴파일시간에 함수를 찍어냄
5. Functional PL
	-> C++, [], filter ...

*/

template <typename T>
void change(T& a, T& b)
{
	T temp{ a };
	a = b;
	b = temp;
}

// -------
int main()
// -------
{

	save("stl.cpp");
}
파일 이름 : stl.cpp, 파일 크기 : 539
저장 시간 : 2022-03-14 11:39:44 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 14 월23						월23 수34				(2주 1일)
// 
// 많은 수의 자료를 다루는 연습
// 1. int -> class
//    int 1000개를 파일에 저장하기
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"


// [문제] 임의의(random) int값 1000개를 화면에 출력하라


// -------
int main()
// -------
{
	for (int i = 0; i < 1000; ++i)
		std::cout << rand() << ' ';

	save("stl.cpp");
}
파일 이름 : stl.cpp, 파일 크기 : 573
저장 시간 : 2022-03-14 11:41:45 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 14 월23						월23 수34				(2주 1일)
// 
// 많은 수의 자료를 다루는 연습
// 1. int -> class
//    int 1000개를 파일에 저장하기
//-----------------------------------------------------------------------------

#include <iostream>
#include <format>
#include "save.h"


// [문제] 임의의(random) int값 1000개를 화면에 출력하라


// -------
int main()
// -------
{
	// 10글자씩 출력하도록 formatting 함
	for (int i = 0; i < 1000; ++i)
		std::cout << std::format("{:10}", rand());

	save("stl.cpp");
}
파일 이름 : stl.cpp, 파일 크기 : 916
저장 시간 : 2022-03-14 12:00:17 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 14 월23						월23 수34				(2주 1일)
// 
// 많은 수의 자료를 다루는 연습
// 1. int -> class
//    int 1000개를 파일에 저장하기
//-----------------------------------------------------------------------------

#include <iostream>
#include <format>
#include "save.h"


// [문제] int의 최대값을 화면에 출력하라
// [문제] 엔진과 분포를 이용하여 임의의(random) int값 1000개를 화면에 출력하라


// -------
int main()
// -------
{
	int num = 0B01111111'11111111'11111111'11111111;
	int n = 0X7FFFFFFF;
	std::cout << num << std::endl;
	std::cout << n << std::endl;
	std::cout << INT_MAX << std::endl;
	
	// int는 기계마다 byte수가 다름, 표준은 2바이트 이상
	// 따라서 다음처럼 numeric 을 통해 자료형의 최댓값을 출력해야함
	std::cout << std::numeric_limits<int>::max << std::endl;

	save("stl.cpp");
}
파일 이름 : stl.cpp, 파일 크기 : 945
저장 시간 : 2022-03-14 12:17:15 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 14 월23						월23 수34				(2주 1일)
// 
// 많은 수의 자료를 다루는 연습
// 1. int -> class
//    int 1000개를 파일에 저장하기
//-----------------------------------------------------------------------------

#include <iostream>
#include <format>
#include <random>
#include "save.h"

// random_device는 개개인의 장치의 특성을 활용하여 시드를 생성함
std::random_device rd;
std::default_random_engine dre{ rd() };
std::uniform_int_distribution<int> uid;

// [문제] 엔진과 분포를 이용하여 임의의(random) int값 1000개를 화면에 출력하라
// normal 분포는 시험이나 과제에 나올 예정

// -------
int main()
// -------
{
	// 엔진의 크기가 크기 때문에 스택에 쓰지 말것
	std::cout << "엔진의 크기 - " << sizeof(dre) << std::endl;

	for (int i = 0; i < 1'000; ++i)
		std::cout << std::format("{:15}", uid(dre));
	
	save("stl.cpp");
}
 파일 이름 : stl.cpp, 파일 크기 : 712
저장 시간 : 2022-03-14 12:18:48 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 14 월23						월23 수34				(2주 1일)
// 
// 많은 수의 자료를 다루는 연습
// 1. int -> class
//    int 1000개를 파일에 저장하기
// 
// 숙제 - 파일 입출력 알아보기
//-----------------------------------------------------------------------------

#include <iostream>
#include <random>
#include "save.h"

std::default_random_engine dre;
std::uniform_int_distribution<int> uid;

// [문제] 엔진과 분포를 이용하여 생성한 int값 1000개를
// 파일 "int 1000개.txt"에 저장하라.

// -------
int main()
// -------
{

	for (int i = 0; i < 1'000; ++i)
		std::cout << uid(dre) << "\t";
	
	save("stl.cpp");
}
파일 이름 : stl.cpp, 파일 크기 : 684
저장 시간 : 2022-03-16 11:42:19 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 16 수34						월23 수34				(2주 2일)
// 
// int 1000개를 파일에 저장하기
// "int 1000개.txt" 에 저장된 int 1000개를 읽어 화면에 출력하라
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <vector>
#include "save.h"


// [문제] 파일 "int 1000개.txt" 에 저장된 int 1000개를 화면에 출력하라

// -------
int main()
// -------
{
	std::ifstream in{ "int 1000개.txt" };

	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };

	for (auto d : v)
		std::cout << d;

	save("stl.cpp");
}
 파일 이름 : stl.cpp, 파일 크기 : 1892
저장 시간 : 2022-03-16 11:46:53 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 14 월23						월23 수34				(2주 1일)
// 
// 많은 수의 자료를 다루는 연습
// 1. int -> class
//    int 1000개를 파일에 저장하기
// 
// 숙제 - 파일 입출력 알아보기
//-----------------------------------------------------------------------------

#include <fstream>
#include <format>

#include <iostream>
#include <random>
#include "save.h"

std::random_device rd;
std::default_random_engine dre(rd());
std::uniform_int_distribution<int> uid;

// [문제] 엔진과 분포를 이용하여 생성한 int값 1000개를
// 파일 "int 1000개.txt"에 저장하라.

// -------
int main()
// -------
{
	// c++이 기본적으로 ANSI 방식으로 텍스트 파일을 읽음
	// 따라서 한글이 있다면 UFT-8 방식으로 읽는다고 명시해야함
	//std::locale::global(std::locale("ko_KR.UTF-8"));

	std::ofstream out("test.txt");

	if (out.is_open()) {
		for (int i = 0; i < 100; ++i) {
			for (int j = 0; j < 10; ++j)
				out << std::format("{:14}", uid(dre));
			out << std::endl;
		}
	}

	std::ifstream in("test.txt");
	

	// 찾아본 방식

	// 1. 한번에 읽기

	/*std::string s;

	if (in.is_open()) {
		in.seekg(0, std::ios::end);
		int size = in.tellg();

		s.resize(size);
		in.seekg(0, std::ios::beg);

		in.read(&s[0], size);
		std::cout << s << std::endl;

	}
	else {
		std::cout << "파일을 찾을 수 없습니다! " << std::endl;
	}*/


	// 2. 한줄씩 읽어오기

	/*if (!in.is_open()) {
		std::cout << "파일을 찾을 수 없습니다! " << std::endl;
		return 0;
	}
	std::string s2;
	while (in) {
		getline(in, s2);
		std::cout << s2 << std::endl;
	}*/



	
	// 벡터를 만들면서 in 파일의 내용을 다 읽어온다.  (STL 컨테이너)
	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };

	// 벡터로 읽어온 파일을 출력한다
	for (auto d : v)
		std::cout << d;

	save("stl.cpp");
}
 파일 이름 : stl.cpp, 파일 크기 : 772
저장 시간 : 2022-03-16 12:00:07 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 16 수34						월23 수34				(2주 2일)
// 
// int 1000개를 파일에 저장하기
// "int 1000개.txt" 에 저장된 int 1000개를 읽어 화면에 출력하라
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

// [문제] 파일 "int 1000개.txt" 에 저장된 int 1000개 중
// 가장 큰 값을 화면에 출력하라

// -------
int main()
// -------
{
	
	std::ifstream in{ "int 1000개.txt" };

	int num;
	int max{ std::numeric_limits<int>::min() };

	for (int i = 0; i < 1'000; ++i) {
		in >> num;
		if (max < num)
			max = num;
	}
	std::cout << "최댓값 : " << max << std::endl;

	save("stl.cpp");
}
파일 이름 : stl.cpp, 파일 크기 : 796
저장 시간 : 2022-03-16 12:04:46 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 16 수34						월23 수34				(2주 2일)
// 
// int 1000개를 파일에 저장하기
// "int 1000개.txt" 에 저장된 int 1000개를 읽어 화면에 출력하라
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

// [문제] 파일 "int 1000개.txt" 에 저장된 int 1000개 중
// 가장 큰 값을 화면에 출력하라

// -------
int main()
// -------
{
	
	std::ifstream in{ "int 1000개.txt" };

	// 아래 함수는 iterator를 리턴함
	// max_element(std::istream_iterator<int>{in}, {})

	std::cout << "최댓값 : " << *max_element(std::istream_iterator<int>{in}, {}) << std::endl;

	save("stl.cpp");
}
파일 이름 : stl.cpp, 파일 크기 : 694
저장 시간 : 2022-03-16 12:05:39 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 16 수34						월23 수34				(2주 2일)
// 
// int 1000개를 파일에 저장하기
// "int 1000개.txt" 에 저장된 int 1000개를 읽어 화면에 출력하라
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

// [문제] 파일 "int 1000개.txt" 에 저장된 int 1000개 중
// 가장 큰 값을 화면에 출력하라

// -------
int main()
// -------
{
	
	std::ifstream in{ "int 1000개.txt" };

	std::cout << "작은 수 - " << *min_element(std::istream_iterator<int>{in}, {}) << std::endl;

	save("stl.cpp");
}
파일 이름 : stl.cpp, 파일 크기 : 790
저장 시간 : 2022-03-16 12:39:58 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 16 수34						월23 수34				(2주 2일)
// 
// int 1000개를 파일에 저장하기
// "int 1000개.txt" 에 저장된 int 1000개를 읽어 화면에 출력하라
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <random>
#include "save.h"

// [문제] int 1000개를 저장하려면 메모리 몇 바이트가 필요합니까?	->		int 저장방식에 따라 달라서 모름
// 이 답에 맞게 int를 파일에 저장하고 메모리 크기를 확인하세요.

// -------
int main()
// -------
{
	// int 메모리를 그대로 기록한다.

	std::ofstream out{ "int 1000개.txt" };

	for (int i{1}; i <= 1'000; ++i)
		out.write( (const char*)&i, sizeof(int));


	save("stl.cpp");
}
파일 이름 : stl.cpp, 파일 크기 : 1118
저장 시간 : 2022-03-16 12:44:22 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 16 수34						월23 수34				(2주 2일)
// 
// int 1000개를 파일에 저장하기
// "int 1000개.txt" 에 저장된 int 1000개를 읽어 화면에 출력하라
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <random>
#include "save.h"

// [문제] int 1000개를 저장하려면 메모리 몇 바이트가 필요합니까?	->		int 저장방식에 따라 달라서 모름
// 이 답에 맞게 int를 파일에 저장하고 메모리 크기를 확인하세요.

std::default_random_engine dre;
std::uniform_int_distribution uid;

// -------
int main()
// -------
{
	// int 메모리를 그대로 기록한다.
	// int 4바이트 씩을 기록했지만 파일은 4024 바이트
	// 그렇다면 무엇은 더 덧붙여 기록했는지 확인할 것
	//  -> os 에 따라 엔터키에 해당하는 바이트를 달리 기록한다.
	//  -> windows 는 엔터키를 2바이트로 할당하여 기록

	std::ofstream out{ "int 1000개.txt" };

	int num;

	for (int i{ 1 }; i <= 1'000; ++i){
		num = uid(dre);
		out.write((const char*)&num, sizeof(int));
	}

	save("stl.cpp");
}
파일 이름 : stl.cpp, 파일 크기 : 1214
저장 시간 : 2022-03-16 12:45:30 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 16 수34						월23 수34				(2주 2일)
// 
// int 1000개를 파일에 저장하기
// "int 1000개.txt" 에 저장된 int 1000개를 읽어 화면에 출력하라
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <random>
#include "save.h"

// [문제] int 1000개를 저장하려면 메모리 몇 바이트가 필요합니까?	->		int 저장방식에 따라 달라서 모름
// 이 답에 맞게 int를 파일에 저장하고 메모리 크기를 확인하세요.

std::default_random_engine dre;
std::uniform_int_distribution uid;

// -------
int main()
// -------
{
	// int 메모리를 그대로 기록한다.
	// int 4바이트 씩을 기록했지만 파일은 4024 바이트
	// 그렇다면 무엇은 더 덧붙여 기록했는지 확인할 것
	//  -> os 에 따라 엔터키에 해당하는 바이트를 달리 기록한다.
	//  -> windows 는 엔터키를 2바이트로 할당하여 기록

	// binary 모드를 이용하면 4바이트 * 1000, 4000바이트만큼만 파일에 기록한다

	std::ofstream out{ "int 1000개.txt", std::ios::binary};

	int num;

	for (int i{ 1 }; i <= 1'000; ++i){
		num = uid(dre);
		out.write((const char*)&num, sizeof(int));
	}

	save("stl.cpp");
}
파일 이름 : stl.cpp, 파일 크기 : 916
저장 시간 : 2022-03-16 12:59:09 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 16 수34						월23 수34				(2주 2일)
// 
// int 1000개를 파일에 저장하기
// "int 1000개.txt" 에 저장된 int 1000개를 읽어 화면에 출력하라
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

// [문제] "int 1000개.txt" 파일에 int 1000개가 binary mod로 저장되어 있다.
// 저장은 stream의 write 함수를 사용하였다.
// 읽어서 가장 큰 값을 화면에 출력하라

// -------
int main()
// -------
{
	std::ifstream in("int 1000개.txt", std::ios::binary);

	// binary mod로 4바이트씩 읽어서 가져오기

	int num;
	int max{};
	
	for (int i{}; i < 1'000; ++i) {
		in.read((char*)&num, sizeof(int));
		if (max < num)
			max = num;
	}
	std::cout << "가장 큰 수 - " << max << std::endl;
	
	save("stl.cpp");
}
파일 이름 : stl.cpp, 파일 크기 : 927
저장 시간 : 2022-03-16 13:06:16 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 16 수34						월23 수34				(2주 2일)
// 
// int 1000개를 파일에 저장하기
// "int 1000개.txt" 에 저장된 int 1000개를 읽어 화면에 출력하라
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <array>
#include "save.h"

// [문제] "int 1000개.txt" 파일에 int 1000개가 binary mod로 저장되어 있다.
// 저장은 stream의 write 함수를 사용하였다.
// 읽어서 가장 큰 값을 화면에 출력하라

// -------
int main()
// -------
{
	std::ifstream in("int 1000개.txt", std::ios::binary);

	// binary mod로 전체를 읽어오기

	std::array<int, 1'000> num;
	int max{};
	
	in.read((char*)num.data(), sizeof(int) * 1000);

	for (int data : num)
		if (max < data)
			max = data;

	std::cout << "가장 큰 수 - " << max << std::endl;
	
	save("stl.cpp");
}
파일 이름 : stl.cpp, 파일 크기 : 1512
저장 시간 : 2022-03-20 21:20:30 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 16 수34						월23 수34				(2주 2일)
// 
// 파일 입출력은 더 이상 알아볼 것이 없다
//	 text / binary  mod 와   read / write 와  >> , <<  의 조합말곤 없기 떄문이다.
// 
// - 파일 입출력 복습 할 것
// 
// 다음 시간 : 메모리
//			   class 입출력
// 
//  숙제 - 동적 메모리 할당
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <memory>
#include "save.h"

// [문제] 사용자가 원하는 갯수만큼 int를 저장할 메모리를 만들어라
// 그 메모리를 1부터 증가하는 int 값으로 채워라


class number
{
public:
	number() { num = 0; }
	number(int a) : num{ a } {}

	void setNumber(int a) { num = a; }

	friend std::ostream& operator<<(std::ostream& os, const number& num);

private:
	int num;
};

std::ostream& operator<<(std::ostream& os, const number& number)
{
	os << number.num;
	return os;
}

// -------
int main()
// -------
{
	int num;
	std::cout << "몇 개의 int 를 원하십니까? ";
	std::cin >> num;

	auto arr = std::make_unique<int[]>(num);

	for (int i{}; i < num; ++i)
		arr[i] = i + 1;

	int sum = 0;
	for (int i{}; i < num; ++i)
		sum += arr[i];

	std::cout << sum << std::endl;




	auto arr2 = std::make_unique<number[]>(num);

	for (int i{}; i < num; ++i)
		arr2[i].setNumber(i + 1);

	for (int i{}; i < num; ++i)
		std::cout << arr2[i] << ' ';




	save("stl.cpp");
}
파일 이름 : stl.cpp, 파일 크기 : 1312
저장 시간 : 2022-03-21 11:15:31 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 21 월23						월23 수34				(3주 1일)
// 
// 지나 시간 - int[1000] 대신 array<int, 1000>을 사용하자
// 
// 컴파일러가 값을 결정하는 2가지 시점
// 1. 컴파일 타임 (Compile Time)
// 2. 실행 시간 (Run Time)
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

// [문제] 사용자가 원하는 갯수만큼 int를 저장할 메모리를 만들어라
// 그 메모리를 1부터 증가하는 int 값으로 채워라
// 다 더한 값을 출력하라
// - 이 과정을 영원히 반복하고 문제없게 고쳐라
// 문제점
// 1. int 는 큰 수를 담을 수 없음
// 2. 메모리를 할당할 수 없을때의 처리가 없음


// -------
int main()
// -------
{
	save("stl.cpp");


	while (true) {
		int num;
		std::cout << "몇 개의 int 를 원하십니까? ";
		std::cin >> num;

		// 메모리를 줄 수 없다고 하면 어떻게 할지 처리
		int* p = new int[num];



		for (int i{}; i < num; ++i)
			p[i] = i + 1;

		// int는 큰수의 합계는 구할 수 없음
		// long long을 사용하면 int보다 큰수의 합계를 구할 수 있으
		int sum{};

		for (int i{}; i < num; ++i)
			sum += p[i];

		std::cout << "1부터 " << num << " 까지의 합은 " << sum << " 입니다. " << std::endl;
	}


	//save("stl.cpp");
}
파일 이름 : stl.cpp, 파일 크기 : 1453
저장 시간 : 2022-03-21 11:22:48 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 21 월23						월23 수34				(3주 1일)
// 
// 지나 시간 - int[1000] 대신 array<int, 1000>을 사용하자
// 
// 컴파일러가 값을 결정하는 2가지 시점
// 1. 컴파일 타임 (Compile Time)
// 2. 실행 시간 (Run Time)
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

// [문제] 사용자가 원하는 갯수만큼 int를 저장할 메모리를 만들어라
// 그 메모리를 1부터 증가하는 int 값으로 채워라
// 다 더한 값을 출력하라
// - 이 과정을 영원히 반복하고 문제없게 고쳐라
// 문제점
// 1. int 는 큰 수를 담을 수 없음
// 2. 메모리를 할당할 수 없을때의 처리가 없음


// -------
int main()
// -------
{
	save("stl.cpp");

	while (true) {
		int num;
		std::cout << "몇 개의 int 를 원하십니까? ";
		std::cin >> num;

		// 메모리를 줄 수 없다고 하면 어떻게 할지 처리
		// try & catch 로 예외처리할 순 있음

		int* p{};
		try {
			p = new int[num];
		}
		catch( std::exception& e ){
			std::cout << e.what() << std::endl;
		}

		for (int i{}; i < num; ++i)
			p[i] = i + 1;

		// int는 큰수의 합계는 구할 수 없음
		// long long을 사용하면 int보다 큰수의 합계를 구할 수 있음
		long long sum{};

		for (int i{}; i < num; ++i)
			sum += p[i];

		std::cout << "1부터 " << num << " 까지의 합은 " << sum << " 입니다. " << std::endl;
	}


	//save("stl.cpp");
}
파일 이름 : stl.cpp, 파일 크기 : 1440
저장 시간 : 2022-03-21 11:26:40 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 21 월23						월23 수34				(3주 1일)
// 
// 지나 시간 - int[1000] 대신 array<int, 1000>을 사용하자
// 
// 컴파일러가 값을 결정하는 2가지 시점
// 1. 컴파일 타임 (Compile Time)
// 2. 실행 시간 (Run Time)
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"

// [문제] 사용자가 원하는 갯수만큼 int를 저장할 메모리를 만들어라
// 그 메모리를 1부터 증가하는 int 값으로 채워라
// 다 더한 값을 출력하라
// - 이 과정을 영원히 반복하고 문제없게 고쳐라
// 문제점
// 1. int 는 큰 수를 담을 수 없음
// 2. 메모리를 할당할 수 없을때의 처리가 없음


// -------
int main()
// -------
{
	save("stl.cpp");

	while (true) {
		int num;
		std::cout << "몇 개의 int 를 원하십니까? ";
		std::cin >> num;

		// 메모리를 줄 수 없다고 하면 어떻게 할지 처리
		// try & catch 로 예외처리할 순 있음
		// 최우선으로 예외처리 대신 메모리 해체로 문제를 발생하지 않게 함

		int* p = new int[num];

		for (int i{}; i < num; ++i)
			p[i] = i + 1;

		// int는 큰수의 합계는 구할 수 없음
		// long long을 사용하면 int보다 큰수의 합계를 구할 수 있음
		long long sum{};

		for (int i{}; i < num; ++i)
			sum += p[i];

		std::cout << "1부터 " << num << " 까지의 합은 " << sum << " 입니다. " << std::endl;

		delete[] p;
	}


	//save("stl.cpp");
}
파일 이름 : stl.cpp, 파일 크기 : 777
저장 시간 : 2022-03-21 11:44:18 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 21 월23						월23 수34				(3주 1일)
// 
// 지난 시간 - int[1000] 대신 array<int, 1000>을 사용하자
// 오늘	     - int* (raw pointer) 대신 unique_ptr<int> 를 사용하자
// 
// 컴파일러가 값을 결정하는 2가지 시점
// 1. 컴파일 타임 (Compile Time)
// 2. 실행 시간 (Run Time)
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <memory>
#include "save.h"

// [문제] 사용자가 원하는 갯수만큼 int를 저장할 메모리를 만들어라
// 그 메모리를 1부터 증가하는 int 값으로 채워라
// 1부터 NUM 까지 더할때 int의 최댓값을 넘지않는 NUM 값은?


// -------
int main()
// -------
{
	
	save("stl.cpp");
}
파일 이름 : stl.cpp, 파일 크기 : 750
저장 시간 : 2022-03-21 11:48:05 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 21 월23						월23 수34				(3주 1일)
// 
// 지난 시간 - int[1000] 대신 array<int, 1000>을 사용하자
// 오늘	     - int* (raw pointer) 대신 unique_ptr<int> 를 사용하자
// 
// 컴파일러가 값을 결정하는 2가지 시점
// 1. 컴파일 타임 (Compile Time)
// 2. 실행 시간 (Run Time)
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <memory>
#include "save.h"

// 자원관리

// -------
int main()
// -------
{
	// std::ifstream in{ "소스.cpp" }; // RAII (resource acquisition is initialization)
	// 포인터 대신 클래스 객체에서 자원을 관리해야함


	save("stl.cpp");
}
파일 이름 : stl.cpp, 파일 크기 : 1062
저장 시간 : 2022-03-21 12:01:01 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 21 월23						월23 수34				(3주 1일)
// 
// 지난 시간 - int[1000] 대신 array<int, 1000>을 사용하자
// 오늘	     - int* (raw pointer) 대신 unique_ptr<int> 를 사용하자
// 
// 컴파일러가 값을 결정하는 2가지 시점
// 1. 컴파일 타임 (Compile Time)
// 2. 실행 시간 (Run Time)
//-----------------------------------------------------------------------------

#include <iostream>
#include <memory>
#include "save.h"

// 자원관리

struct Dog{
	Dog() { std::cout << "생성" << std::endl; }
	~Dog() { std::cout << "소멸" << std::endl; }
};

void f()
{
	//throw 1;
}

// -------
int main()
// -------
{
	// 전통적인 자원관리 방식
	// 예외점마다 자원의 해제를 반드시 해야함
	// 프로그램이 커지면 커질수록 오류를 찾기 힘들어짐

	save("stl.cpp");

	Dog* dogs = new Dog[3];

	// 비상상황 - f()에서 예외 발생
	try {
		f();
	}
	catch (...) {
		std::cout << "예외를 잘 잡았다" << std::endl;
		delete[] dogs;
		return 0;
	}

	delete[] dogs;
}
파일 이름 : stl.cpp, 파일 크기 : 961
저장 시간 : 2022-03-21 12:04:35 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 21 월23						월23 수34				(3주 1일)
// 
// 지난 시간 - int[1000] 대신 array<int, 1000>을 사용하자
// 오늘	     - int* (raw pointer) 대신 unique_ptr<int> 를 사용하자
// 
// 컴파일러가 값을 결정하는 2가지 시점
// 1. 컴파일 타임 (Compile Time)
// 2. 실행 시간 (Run Time)
//-----------------------------------------------------------------------------

#include <iostream>
#include <memory>
#include "save.h"

// 자원관리

struct Dog{
	Dog() { std::cout << "생성" << std::endl; }
	~Dog() { std::cout << "소멸" << std::endl; }
};

void f()
{
	throw 1;
}

// -------
int main()
// -------
{

	save("stl.cpp");

	auto dogs = std::make_unique<Dog[]>(3);
	//std::unique_ptr<Dog[]> dogs{ new Dog[3] };

	// 비상상황 - f()에서 예외 발생
	try {
		f();
	}
	catch (...) {
		std::cout << "예외를 잘 잡았다" << std::endl;
		return 0;
	}

}
파일 이름 : stl.cpp, 파일 크기 : 1012
저장 시간 : 2022-03-21 12:20:42 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 21 월23						월23 수34				(3주 1일)
// 
// 지난 시간 - int[1000] 대신 array<int, 1000>을 사용하자
// 오늘	     - int* (raw pointer) 대신 unique_ptr<int> 를 사용하자
// 
// 컴파일러가 값을 결정하는 2가지 시점
// 1. 컴파일 타임 (Compile Time)
// 2. 실행 시간 (Run Time)
// 
// 찾아보기 - RAII / Stack unwinding
//-----------------------------------------------------------------------------

#include <iostream>
#include <memory>
#include "save.h"

// [문제] "stl.cpp" 를 읽어
// 소문자를 전부 대문자로 변경하여
// "소스 대문자.cpp" 에 저장하라

// -------
int main()
// -------
{
	save("stl.cpp");
	
	// 유니크 포인터는 자동으로 해제하기에 아래 프로그램은 죽지 않는다

	while (true) {
		
		
		std::unique_ptr<int[]> p{ new int[1'000'000'000] };

		long long sum{};
		for (int i = 0; i < 1'000'000'000; ++i)
			sum += p[i];

		std::cout << "합계 - " << sum << std::endl;

	}
	
}
파일 이름 : stl.cpp, 파일 크기 : 1975
저장 시간 : 2022-03-22 23:38:50 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 21 월23						월23 수34				(3주 1일)
// 
// 지난 시간 - int[1000] 대신 array<int, 1000>을 사용하자
// 오늘	     - int* (raw pointer) 대신 unique_ptr<int> 를 사용하자
// 
// 컴파일러가 값을 결정하는 2가지 시점
// 1. 컴파일 타임 (Compile Time)
// 2. 실행 시간 (Run Time)
// 
// 찾아보기 - RAII / Stack unwinding
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <string>
#include <algorithm>
#include <vector>
#include "save.h"

// [문제] "stl.cpp" 를 읽어
// 소문자를 전부 대문자로 변경하여
// "소스 대문자.cpp" 에 저장하라


// -------
int main()
// -------
{
	std::ifstream in("stl.cpp");

	std::ofstream out("소스 대문자.cpp");


	// 한번에 읽기

	//std::string s;

	//if (in) {
	//	in.seekg(0, std::ios::end);
	//	
	//	int size = in.tellg();
	//	s.resize(size);

	//	in.seekg(0, std::ios::beg);

	//	in.read(&s[0], size);
	//	
	//	/*for (int i = 0; i < s.size(); ++i) {
	//		s[i] = toupper(s[i]);
	//	}*/

	//	// 알고리즘으로 처리		(바꿀 것의 시작, 끝,  바꾼것이 담길 목적지의 시작점, 바뀔 방법)
	//	std::transform(s.begin(), s.end(), s.begin(), [](unsigned char c) {return toupper(c); });

	//	out << s << std::endl;
	//}
	//else {
	//	std::cout << "파일을 찾을 수 없습니다 " << std::endl;
	//}


	// 한줄씩 읽기

	/*std::string s2;

	if (!in) {
		std::cout << "파일을 찾을 수 없습니다 " << std::endl;
	}
	
	while (in) {
		std::getline(in, s2);
		for (int i = 0; i < s2.size(); ++i)
			s2[i] = toupper(s2[i]);
		out << s2 << std::endl;
	}*/


	
	// STL 컨테이너 활용
	std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };

	for (int i = 0; i < v.size(); ++i) {
		if (v[i] >= 'a' && v[i] <= 'z')
			v[i] -= 32;
	}

	copy(v.begin(), v.end(), std::ostream_iterator<char>{out});

	

	save("stl.cpp");
}
파일 이름 : stl.cpp, 파일 크기 : 1943
저장 시간 : 2022-03-23 11:53:55 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 23 수34						월23 수34				(3주 2일)
// 
// 오늘 - 호출가능 타입(callable type) - 정렬(sort)
// 자원을 관리하는 클래스 - STRING (컨테이너, 반복자, 알고리즘)
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <string>
#include <algorithm>
#include <vector>
#include "save.h"

// [문제] "stl.cpp" 를 읽어
// 소문자를 전부 대문자로 변경하여
// "소스 대문자.cpp" 에 저장하라


// -------
int main()
// -------
{
	std::ifstream in("stl.cpp");

	std::ofstream out("소스 대문자.cpp");

	// 한번에 읽기

	//std::string s;

	//if (in) {
	//	in.seekg(0, std::ios::end);
	//	
	//	int size = in.tellg();
	//	s.resize(size);

	//	in.seekg(0, std::ios::beg);

	//	in.read(&s[0], size);
	//	
	//	/*for (int i = 0; i < s.size(); ++i) {
	//		s[i] = toupper(s[i]);
	//	}*/

	//	// 알고리즘으로 처리		(바꿀 것의 시작, 끝,  바꾼것이 담길 목적지의 시작점, 바뀔 방법)
	//	std::transform(s.begin(), s.end(), s.begin(), [](unsigned char c) {return toupper(c); });

	//	out << s << std::endl;
	//}
	//else {
	//	std::cout << "파일을 찾을 수 없습니다 " << std::endl;
	//}


	// 한줄씩 읽기

	/*std::string s2;

	if (!in) {
		std::cout << "파일을 찾을 수 없습니다 " << std::endl;
	}
	
	while (in) {
		std::getline(in, s2);
		for (int i = 0; i < s2.size(); ++i)
			s2[i] = toupper(s2[i]);
		out << s2 << std::endl;
	}*/


	
	// STL 컨테이너 활용

	/*std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };

	for (int i = 0; i < v.size(); ++i) 
		v[i] = toupper(v[i]);

	copy(v.begin(), v.end(), std::ostream_iterator<char>{out});*/

	

	// 한글자씩 쭉 읽어들이기

	char ch;

	// \n 건너뛰지않게 함
	in >> std::noskipws;

	while (in >> ch) {
		ch = toupper(ch);
		out << ch;
	}

	save("stl.cpp");
}
파일 이름 : stl.cpp, 파일 크기 : 2125
저장 시간 : 2022-03-23 12:02:26 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 23 수34						월23 수34				(3주 2일)
// 
// 오늘 - 호출가능 타입(callable type) - 정렬(sort)
// 자원을 관리하는 클래스 - STRING (컨테이너, 반복자, 알고리즘)
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <algorithm>
#include "save.h"

// [문제] "stl.cpp" 를 읽어
// 소문자를 전부 대문자로 변경하여
// "소스 대문자.cpp" 에 저장하라


// -------
int main()
// -------
{
	std::ifstream in("stl.cpp");
	std::ofstream out("소스 대문자.cpp");

	// ★STL 컨테이너 활용한 변환★
	std::transform(std::istreambuf_iterator<char>{in}, {}, std::ostreambuf_iterator<char>{out}, [](char c) { return toupper(c); });

	save("stl.cpp");
}
파일 이름 : stl.cpp, 파일 크기 : 1201
저장 시간 : 2022-03-23 12:24:42 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 23 수34						월23 수34				(3주 2일)
// 
// 오늘 - 호출가능 타입(callable type) - 정렬(sort)
// 자원을 관리하는 클래스 - STRING (컨테이너, 반복자, 알고리즘)
//-----------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <random>
#include <format>
#include <algorithm>
#include "save.h"

// [문제] 값이 [1, 100] 랜덤 int 100개를 생성하고
// 오름차순, 내림차순으로 정렬한 후 
// 정렬된 int 100개를 화면에 출력하시오.

std::default_random_engine dre;
std::uniform_int_distribution uid{ 1,100 };

// -------
int main()
// -------
{
	std::array<int, 100> arr;

	for (auto& data : arr)
		data = uid(dre);

	std::cout << "정렬 전" << std::endl;
	for (auto data : arr)
		std::cout << std::format("{:4}", data);

	std::cout << std::endl << std::endl;

	// default 오름차순
	// std::sort(arr.begin(), arr.end());

	// 내림차순
	// std::sort(arr.begin(), arr.end(), std::greater<>());  	
	std::sort(arr.begin(), arr.end(), [](int a, int b) { return a > b; });

	std::cout << "정렬 후" << std::endl;
	for (auto data : arr)
		std::cout << std::format("{:4}", data);

	save("stl.cpp");
}
파일 이름 : stl.cpp, 파일 크기 : 863
저장 시간 : 2022-03-23 12:59:34 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 23 수34						월23 수34				(3주 2일)
// 
// 오늘 - 호출가능 타입(callable type) - 정렬(sort)
// 자원을 관리하는 클래스 - STRING (컨테이너, 반복자, 알고리즘)
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"

// [문제] 값이 [1, 100] 랜덤 int 100개를 생성하고
// 오름차순, 내림차순으로 정렬한 후 
// 정렬된 int 100개를 화면에 출력하시오.

int f(int a, int b) { return a + b; }

void g() { std::cout << "함수 호출됨" << std::endl; }

// -------
int main()
// -------
{
	auto x = f;
	int res = (*x)(1, 2);

	std::cout << res << std::endl;

	auto p = g;
	p();
	std::cout << typeid(p).name() << std::endl;
	std::cout << std::addressof(x) << std::endl;


	save("stl.cpp");
}
파일 이름 : stl.cpp, 파일 크기 : 860
저장 시간 : 2022-03-23 13:09:20 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 23 수34						월23 수34				(3주 2일)
// 
// 오늘 - 호출가능 타입(callable type) - 정렬(sort)
// 자원을 관리하는 클래스 - STRING (컨테이너, 반복자, 알고리즘)
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"

void jump() { std::cout << "점프" << std::endl; }

void slide() { std::cout << "슬라이드" << std::endl; }

// -------
int main()
// -------
{
	void (*x)(void) = jump;
	x();

	x = slide;
	x();

	// 함수를 가리키는 포인터를 통해 어떤 함수를 호출할지(기능)를 변경할 수 있다.
	// 게임에선 키변경에 사용할 수 있음

	save("stl.cpp");
}
파일 이름 : stl.cpp, 파일 크기 : 1571
저장 시간 : 2022-03-23 13:20:42 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 23 수34						월23 수34				(3주 2일)
// 
// 오늘 - 호출가능 타입(callable type) : () 로 호출할 수 있는가  ->  정렬(sort)에 사용
// 자원을 관리하는 클래스 - STRING (컨테이너, 반복자, 알고리즘)
// 
// 숙제 - 호출가능 타입 공부
//-----------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <random>
#include <format>
#include <algorithm>
#include "save.h"

// [문제] 값이 [1, 100] 랜덤 int 100개를 생성하고
// 오름차순, 내림차순으로 정렬한 후 
// 정렬된 int 100개를 화면에 출력하시오.

std::default_random_engine dre;
std::uniform_int_distribution uid{ 1,100 };

template<typename T>
T game(T a, T b)
{
	return a > b;
}

class Dog {

public:
	void operator()(void) {
		std::cout << "나를 부를 수 있다" << std::endl;
	}
};

// -------
int main()
// -------
{
	//int (*f)(void);
	//f();  -> () 함수호출 연산자

	Dog dog;
	dog();

	std::array<int, 100> arr;

	for (auto& data : arr)
		data = uid(dre);

	std::cout << "정렬 전" << std::endl;
	for (auto data : arr)
		std::cout << std::format("{:4}", data);

	std::cout << std::endl << std::endl;

	// default 오름차순
	// std::sort(arr.begin(), arr.end());

	// 내림차순
	// std::sort(arr.begin(), arr.end(), std::greater<>());  	
	std::sort(arr.begin(), arr.end(), game<int>);

	std::cout << "정렬 후" << std::endl;
	for (auto data : arr)
		std::cout << std::format("{:4}", data);

	save("stl.cpp");
}파일 이름 : stl.cpp, 파일 크기 : 1030
저장 시간 : 2022-03-28 10:54:54 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 28 월23						월23 수34				(4주 1일)
// 
// 오늘 - 호출가능 타입(callable type) : () 로 호출할 수 있는가  ->  정렬(sort)에 사용
// 자원을 관리하는 클래스 - STRING (컨테이너, 반복자, 알고리즘)
// 
// 숙제 - 호출가능 타입 공부
//-----------------------------------------------------------------------------

#include <iostream>
#include <thread>
#include "save.h"

// 프로그램에서 기능을 담당 - 서브루틴, 함수
// 프로그램이 실행될 때 기능을 변경하고 싶다

// 게임 - 설정 - 버튼의 기능변경

void jump() 
{
	std::cout << "점프" << std::endl;
}

void slide() 
{
	std::cout << "슬라이드" << std::endl;
}

// -------
int main()
// -------
{
	save("stl.cpp");

	auto f = jump;

	int cnt{};
	while (true){
		f();		// 이 게임은 f만 호출
		using namespace std::literals;
		std::this_thread::sleep_for(1s);

		if (++cnt % 3 == 0) {
			if (f == jump)
				f = slide;
			else
				f = jump;
		}
	}


	
}파일 이름 : stl.cpp, 파일 크기 : 891
저장 시간 : 2022-03-28 11:18:32 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 28 월23						월23 수34				(4주 1일)
// 
// 오늘 - 호출가능 타입(callable type) : () 로 호출할 수 있는가  ->  정렬(sort)에 사용
// 자원을 관리하는 클래스 - STRING (컨테이너, 반복자, 알고리즘)
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"

// 호출가능 타입(callable type) 
// 1. 함수 포인터 (함수가 아닌 함수 포인터) - 함수의 시작번지를 저장할 수 있다
// 2. 람다(lambda) - 이름없는 함수   (일반함수와의 차이점   1. 이름이 없어서 따로 지정하지 않으면 호출 불가  2. 지역내에 존재)
// 3. ()를 오버로딩한 클래스
// 4, 멤버함수 포인터

// -------
int main()
// -------
{
	auto x = [](){
		std::cout << "람다 호출" << std::endl;
	};

	std::cout << typeid(x).name() << std::endl;

	save("stl.cpp");
	
}파일 이름 : stl.cpp, 파일 크기 : 1029
저장 시간 : 2022-03-28 11:20:14 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 28 월23						월23 수34				(4주 1일)
// 
// 오늘 - 호출가능 타입(callable type) : () 로 호출할 수 있는가  ->  정렬(sort)에 사용
// 자원을 관리하는 클래스 - STRING (컨테이너, 반복자, 알고리즘)
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"

// 호출가능 타입(callable type) 
// 1. 함수 포인터 (함수가 아닌 함수 포인터) - 함수의 시작번지를 저장할 수 있다
// 2. 람다(lambda) - 이름없는 함수   (일반함수와의 차이점   1. 이름이 없어서 따로 지정하지 않으면 호출 불가  2. 지역내에 존재)
// 3. ()를 오버로딩한 클래스
// 4, 멤버함수 포인터

class Dog {};

// -------
int main()
// -------
{

	class Bird {};
	std::cout << typeid(Dog).name() << std::endl;
	std::cout << typeid(Bird).name() << std::endl;

	auto x = []() {
		std::cout << "람다 호출" << std::endl;
	};

	std::cout << typeid(x).name() << std::endl;


	save("stl.cpp");
	
}파일 이름 : stl.cpp, 파일 크기 : 1164
저장 시간 : 2022-03-28 11:31:25 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 28 월23						월23 수34				(4주 1일)
// 
// 오늘 - 호출가능 타입(callable type) : () 로 호출할 수 있는가  ->  정렬(sort)에 사용
// 자원을 관리하는 클래스 - STRING (컨테이너, 반복자, 알고리즘)
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"

// 호출가능 타입(callable type) 
// 1. 함수 포인터 (함수가 아닌 함수 포인터) - 함수의 시작번지를 저장할 수 있다
// 2. 람다(lambda) - 이름없는 함수   
//    (일반함수와의 차이점   1. 이름이 없어서 따로 지정하지 않으면 호출 불가  2. 지역내에 존재)
//				  ??? 이름이 없는데 누가 어떻게 불러쓰나? -> 정렬과 같은 알고리즘에서 사용
// 
// 
// 
// 3. ()를 오버로딩한 클래스
// 4, 멤버함수 포인터



// -------
int main()
// -------
{	
	std::array<int, 5> a{ 1,3,5,2,4 };

	// sort( 반복자 begin, 반복자 end, 호출가능타입 f) {  f(a, b); }
	std::sort(a.begin(), a.end(), [](int a, int b) {
		return a > b; 
		});

	for (auto num : a)
		std::cout << num << " ";


	save("stl.cpp");
	
}파일 이름 : stl.cpp, 파일 크기 : 1194
저장 시간 : 2022-03-28 11:35:05 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 28 월23						월23 수34				(4주 1일)
// 
// 오늘 - 호출가능 타입(callable type) : () 로 호출할 수 있는가  ->  정렬(sort)에 사용
// 자원을 관리하는 클래스 - STRING (컨테이너, 반복자, 알고리즘)
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"

// 호출가능 타입(callable type) 
// 1. 함수 포인터 (함수가 아닌 함수 포인터) - 함수의 시작번지를 저장할 수 있다
// 2. 람다(lambda) - 이름없는 함수   
//    (일반함수와의 차이점   1. 이름이 없어서 따로 지정하지 않으면 호출 불가  2. 지역내에 존재)
//				  ??? 이름이 없는데 누가 어떻게 불러쓰나? -> 정렬과 같은 알고리즘에서 사용
// 
// 3. ()를 오버로딩한 클래스
// 4, 멤버함수 포인터

class Dog {
public:
	bool operator()(int a, int b) {
		std::cout << "Dog의 멤버 " << a << " < " << b << std::endl;
		return a < b;
	}
};

// -------
int main()
// -------
{	
	std::array<int, 5> a{ 1,3,5,2,4 };

	std::sort(a.begin(), a.end(), Dog{} );

	for (auto num : a)
		std::cout << num << " ";


	save("stl.cpp");
	
}파일 이름 : stl.cpp, 파일 크기 : 1249
저장 시간 : 2022-03-28 11:51:34 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 28 월23						월23 수34				(4주 1일)
// 
// 오늘 - 호출가능 타입(callable type) : () 로 호출할 수 있는가  ->  정렬(sort)에 사용
// 자원을 관리하는 클래스 - STRING (컨테이너, 반복자, 알고리즘)
// 
//-----------------------------------------------------------------------------

#include <iostream>
#include <functional>
#include "save.h"

// 호출가능 타입(callable type) 
// 1. 함수 포인터 (함수가 아닌 함수 포인터) - 함수의 시작번지를 저장할 수 있다
// 2. 람다(lambda) - 이름없는 함수   
//    (일반함수와의 차이점   1. 이름이 없어서 따로 지정하지 않으면 호출 불가  2. 지역내에 존재)
//				  ??? 이름이 없는데 누가 어떻게 불러쓰나? -> 정렬과 같은 알고리즘에서 사용
// 
// 3. ()를 오버로딩한 클래스 - functor
// 4, 멤버함수 포인터


// 호출가능한 타입의 종류? - 무한

// function - 어떤 호출가능한 타입이더라도 function 객체로 대표할 수 있다

void jump()
{
	std::cout << "점프" << std::endl;
}

void slide()
{
	std::cout << "슬라이드" << std::endl;
}


// -------
int main()
// -------
{	
	// 호출가능 타입을 아래처럼 사용 가능
	std::function<void()> f = jump;
	f();

	f = slide;
	f();

	save("stl.cpp");
	
} 파일 이름 : stl.cpp, 파일 크기 : 1981
저장 시간 : 2022-03-30 12:09:01 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 31 수34						월23 수34				(4주 2일)
// 
// 자원을 관리하는 클래스 - STRING (컨테이너, 반복자, 알고리즘)
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"

// [STL 관찰용] STRING 클래스 작성한다
// 자원을 관리하는 클래스이다(RAII)
// 관찰을 위해 스페셜 함수의 동작을 화면에 출력할 수 있게 한다.
// 표준 string 클래스의 동작과 같이 코딩한다. (string을 사용하지 않는다)
// 객체 생성시 고유번호를 부여
// Release 모드에서 해야함

bool 관찰{ false };

class STRING {
public:
	STRING() : id{ ++gid }, num{}, p{} {
		if (관찰)
			print("디폴트 생성자");
	}

	STRING(const char* s) : id{ ++gid }, num{ strlen(s) }, p{ new char[num] } {
		if (관찰)
			print("생성자(const char*)");
		memcpy(p, s, num);
	}
	
	~STRING() { 
		if (관찰)
			print("소멸자");

		if(num)
			delete[] p; 
	}


	STRING operator+(const STRING& rhs) const {
		STRING temp;
		temp.num = num + rhs.num;
		temp.p = new char[temp.num];
		memcpy(temp.p, p, num);
		memcpy(temp.p + num, rhs.p, rhs.num);
		return temp;

	}

	void print(const char* s) const {
		std::cout << s << " [" << id << "] 객체주소 : " << this << " 자원 -";
		if (num != 0)
			std::cout << " 갯수 : " << num << " 자원 주소: " << (void*)p << std::endl;
		else
			std::cout << "  없음" << std::endl;
	}


	friend std::ostream& operator<<(std::ostream&, const STRING&);

private:
	char* p;				// 확보한 자원 주소
	size_t num;				// 관리하는 바이트 수
	int id;					// 생성 시 id
	static int gid;			// 클래스 스태틱 - id 관리
};

int STRING::gid{};

std::ostream& operator<<(std::ostream& os, const STRING& s)
{
	for (int i{}; i < s.num; ++i)
		os << s.p[i];
	return os;
}

// -------
int main()
// -------
{	
	save("stl.cpp");

	// 관찰 = true;
	STRING a{"2022. 3. 28" };
	STRING b{ "STL" };
	
	std::cout << a + b << std::endl;
	
} 파일 이름 : stl.cpp, 파일 크기 : 2446
저장 시간 : 2022-03-30 12:21:59 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 31 수34						월23 수34				(4주 2일)
// 
// 자원을 관리하는 클래스 - STRING (컨테이너, 반복자, 알고리즘)
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"

// [STL 관찰용] STRING 클래스 작성한다
// 자원을 관리하는 클래스이다(RAII)
// 관찰을 위해 스페셜 함수의 동작을 화면에 출력할 수 있게 한다.
// 표준 string 클래스의 동작과 같이 코딩한다. (string을 사용하지 않는다)
// 객체 생성시 고유번호를 부여

bool 관찰{ false };

class STRING {
public:
	STRING() : id{ ++gid }, num{}, p{} {
		if (관찰)
			print("디폴트 생성자");
	}

	STRING(const char* s) : id{ ++gid }, num{ strlen(s) }, p{ new char[num] } {
		memcpy(p, s, num);
		if (관찰)
			print("생성자(const char*)");
	}
	
	~STRING() { 
		if (관찰)
			print("소멸자");

		if(num)
			delete[] p; 
	}

	STRING(const STRING& other) : id{ ++gid }, num{ other.num }, p{ new char[num] } {
		memcpy(p, other.p, num);
		if (관찰)
			print("복사 생성자");
	}

	STRING& operator=(const STRING& other) {
		if (this == &other)
			return *this;
		num = other.num;
		delete[] p;
		p = new char[num];
		memcpy(p, other.p, num);
		return *this;
	}

	STRING operator+(const STRING& rhs) const {
		STRING temp;
		temp.num = num + rhs.num;
		temp.p = new char[temp.num];
		memcpy(temp.p, p, num);
		memcpy(temp.p + num, rhs.p, rhs.num);

		if (관찰)
			print("복사할당");

		return temp;

	}

	void print(const char* s) const {
		std::cout << s << " [" << id << "] 객체주소 : " << this << " 자원 -";
		if (num != 0)
			std::cout << " 갯수 : " << num << " 자원 주소: " << (void*)p << std::endl;
		else
			std::cout << "  없음" << std::endl;
	}


	friend std::ostream& operator<<(std::ostream&, const STRING&);

private:
	char* p;				// 확보한 자원 주소
	size_t num;				// 관리하는 바이트 수
	int id;					// 생성 시 id
	static int gid;			// 클래스 스태틱 - id 관리
};

int STRING::gid{};

std::ostream& operator<<(std::ostream& os, const STRING& s)
{
	for (int i{}; i < s.num; ++i)
		os << s.p[i];
	return os;
}

// -------
int main()
// -------
{	
	관찰 = true;

	STRING a{"2022. 3. 28 " };
	STRING b{ "STL" };
	STRING c = a + b;		

	std::cout << a << std::endl;
	std::cout << b << std::endl;
	std::cout << c << std::endl;


	save("stl.cpp");
} 파일 이름 : stl.cpp, 파일 크기 : 616
저장 시간 : 2022-03-30 12:46:32 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 31 수34						월23 수34				(4주 2일)
// 
// 자원을 관리하는 클래스 - STRING (컨테이너, 반복자, 알고리즘)
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// -------
int main()
// -------
{	
	관찰 = true;

	STRING a{"2022. 3. 28 " };
	STRING b{ "STL" };
	STRING c = a + b;		

	std::cout << a << std::endl;
	std::cout << b << std::endl;
	std::cout << c << std::endl;


	save("stl.cpp");
} 파일 이름 : stl.cpp, 파일 크기 : 660
저장 시간 : 2022-03-30 12:47:37 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 31 수34						월23 수34				(4주 2일)
// 
// 자원을 관리하는 클래스 - STRING (컨테이너, 반복자, 알고리즘)
//-----------------------------------------------------------------------------

#include <iostream>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// -------
int main()
// -------
{	
	관찰 = true;

	STRING a{"2022. 3. 28 " };
	STRING b{ "STL" };
	STRING c = a + b;		

	std::cout << a << std::endl;
	std::cout << b << std::endl;
	std::cout << c << std::endl;


	save("stl.cpp");
	save("STRING.h");
	save("STRING.cpp");

} 파일 이름 : STRING.h, 파일 크기 : 777
저장 시간 : 2022-03-30 12:47:37 GMT+9

//-----------------------------------------------------------------------------
// STRING - STL 관찰하려고 만든 자원 관리 클래스
// 
// 2022. 3. 30									Programmed by Taegrim
//-----------------------------------------------------------------------------

#pragma once

#include <iostream>

class STRING {
public:
	STRING();

	STRING(const char* s);

	~STRING();

	STRING(const STRING& other);

	STRING& operator=(const STRING& other);

	STRING operator+(const STRING& rhs) const;

	void print(const char* s) const;


	friend std::ostream& operator<<(std::ostream&, const STRING&);

private:
	char* p;				// 확보한 자원 주소
	size_t num;				// 관리하는 바이트 수
	int id;					// 생성 시 id
	static int gid;			// 클래스 스태틱 - id 관리
};
파일 이름 : STRING.cpp, 파일 크기 : 1748
저장 시간 : 2022-03-30 12:47:37 GMT+9

//-----------------------------------------------------------------------------
// STRING - STL 관찰하려고 만든 자원 관리 클래스
// 
// 2022. 3. 30									Programmed by Taegrim
//-----------------------------------------------------------------------------

#include <iostream>
#include "STRING.h"

bool 관찰{ false };		// 관찰메세지를 보려면 -> true
int STRING::gid{};		// STRING static


STRING::STRING() : id{ ++gid }, num{}, p{} 
{
	if (관찰)
		print("디폴트 생성자");
}

STRING::STRING(const char* s) : id{ ++gid }, num{ strlen(s) }, p{ new char[num] } 
{
	memcpy(p, s, num);
	if (관찰)
		print("생성자(const char*)");
}

STRING::~STRING() 
{
	if (관찰)
		print("소멸자");
	if (num)
		delete[] p;
}

STRING::STRING(const STRING& other) 
	: id{ ++gid }, num{ other.num }, p{ new char[num] } 
{
	memcpy(p, other.p, num);
	if (관찰)
		print("복사 생성자");
}

STRING& STRING::operator=(const STRING& other) 
{
	if (this == &other)
		return *this;

	num = other.num;
	delete[] p;
	p = new char[num];
	memcpy(p, other.p, num);

	if (관찰)
		print("복사할당");

	return *this;
}

STRING STRING::operator+(const STRING& rhs) const 
{
	STRING temp;
	temp.num = num + rhs.num;
	temp.p = new char[temp.num];
	memcpy(temp.p, p, num);
	memcpy(temp.p + num, rhs.p, rhs.num);

	return temp;

}

void STRING::print(const char* s) const 
{
	std::cout << s << " [" << id << "] 객체주소 : " << this << " 자원 -";
	if (num != 0)
		std::cout << " 갯수 : " << num << " 자원 주소: " << (void*)p << std::endl;
	else
		std::cout << "  없음" << std::endl;
}

std::ostream& operator<<(std::ostream& os, const STRING& s)
{
	for (int i{}; i < s.num; ++i)
		os << s.p[i];
	return os;
}
파일 이름 : stl.cpp, 파일 크기 : 683
파일 이름 : stl.cpp, 파일 크기 : 683
저장 시간 : 2022-03-30 13:16:12 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 31 수34						월23 수34				(4주 2일)
// 
// 자원을 관리하는 클래스 - STRING (컨테이너, 반복자, 알고리즘)
//-----------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// -------
int main()
// -------
{	
	관찰 = true;

	save("stl.cpp");
	//STRING strs[3];
	//strs[0].operator=(STRING{ "123" });

	STRING s{ "12345" };
	STRING s2{ "1234567890" };

	s = s2;

	std::cout << s << std::endl;

	
	// cppreference.com 에서 Containers Library 부분 볼것
} 파일 이름 : stl.cpp, 파일 크기 : 973
저장 시간 : 2022-04-01 23:12:48 GMT+9

//-----------------------------------------------------------------------------
// 2022. 3. 31 수34						월23 수34				(4주 2일)
// 
// 자원을 관리하는 클래스 - STRING (컨테이너, 반복자, 알고리즘)
//-----------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// -------
int main()
// -------
{	
	//관찰 = true;

	std::array<STRING, 3> strs{ "2022년 1학기 STL", "월23 수34", "3월 30일 수요일 수34교시 4주 2일 강의" };

	for (int i = 0; i < strs.size(); ++i)
		std::cout << "strs[" << i << "] - " << strs[i] << std::endl;

	std::cout << std::endl << std::endl;
	std::cout << "strs의 STRING 3객체를 모두 더한 객체를 만들어 본다" << std::endl << std::endl;

	STRING all = strs[0] + strs[1] + strs[2];
	std::cout << "모두 더하면 - " << all << std::endl;

	save("stl.cpp");
	
	// cppreference.com 에서 Containers Library 부분 볼것
} 파일 이름 : stl.cpp, 파일 크기 : 888
저장 시간 : 2022-04-04 10:52:22 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 4 월23						월23 수34				(5주 1일)
// 
// 자원을 관리하는 클래스 - STRING (컨테이너, 반복자, 알고리즘)
//-----------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// -------
int main()
// -------
{	
	// 관찰 = true;

	std::array<STRING, 3> a{ "컨테이너", "반복자" , "알고리즘" };

	// [문제] a에 들어있는 원소(element)를 처음부터 끝까지 순회(iteration)하면서 
	// 값을 출력해보라


	for (std::array<STRING, 3>::iterator it = a.begin(); it != a.end(); ++it)
		std::cout << *it << std::endl;;

	//for (auto data : a)
	//	std::cout << data << " ";
	//std::cout << std::endl;
	//// 이 방식은 복사생성을 하기 떄문에 효율이 떨어짐
	//// 레퍼런스로 접근 시 원본을 받기에 위와 효율이 같아짐, 읽기동작은 const 지정

	save("stl.cpp");
} 파일 이름 : stl.cpp, 파일 크기 : 898
저장 시간 : 2022-04-04 11:05:58 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 4 월23						월23 수34				(5주 1일)
// 
// 자원을 관리하는 클래스 - STRING (컨테이너, 반복자, 알고리즘)
//-----------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// -------
int main()
// -------
{	
	관찰 = true;

	std::array<STRING, 3> a{ "컨테이너", "반복자" , "알고리즘" };

	// [문제] a에 들어있는 원소(element)를 처음부터 끝까지 순회(iteration)하면서 
	// 값을 출력해보라


	//for (auto it = a.cbegin(); it != a.cend(); ++it)
	//	std::cout << *it << std::endl;;

	//for (const auto& data : a)
	//	std::cout << data << " ";
	//std::cout << std::endl;

	for (int i = 0; i < a.size(); ++i)
		std::cout << a.at(i) << std::endl;



	save("stl.cpp");
} 파일 이름 : stl.cpp, 파일 크기 : 774
저장 시간 : 2022-04-04 11:10:56 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 4 월23						월23 수34				(5주 1일)
// 
// 자원을 관리하는 클래스 - STRING (컨테이너, 반복자, 알고리즘)
//-----------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// -------
int main()
// -------
{	
	관찰 = true;

	std::array<STRING, 3> a{ "컨테이너", "반복자" , "알고리즘" };

	// [문제] a에 들어있는 원소(element)를 처음부터 끝까지 역방향으로 순회(iteration)하면서 
	// 값을 출력해보라

	// a.rend() -> 반복자 어댑터 라고 부름
	for (auto it = a.crbegin(); it != a.crend(); ++it)
		std::cout << *it << std::endl;


	save("stl.cpp");
} 파일 이름 : stl.cpp, 파일 크기 : 880
저장 시간 : 2022-04-04 11:35:22 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 4 월23						월23 수34				(5주 1일)
// 
// 자원을 관리하는 클래스 - STRING (컨테이너, 반복자, 알고리즘)
//-----------------------------------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// -------
int main()
// -------
{	
	// 관찰 = true;

	std::array<STRING, 3> a{ "12345", "33" , "123456789" };

	// [문제] array를 길이 오름차순으로 정렬하고 결과를 출력하라

	// 아래 정렬에서 레퍼런스를 쓰지 않으면 복사생성이 많이 일어나 효율이 매우 떨어짐
	std::sort(a.begin(), a.end(), []( const STRING& a, const STRING& b ){
			return a.getNum() < b.getNum();
		} );

	for (const auto& data : a)
		std::cout << data << std::endl;

	save("stl.cpp");
} 파일 이름 : stl.cpp, 파일 크기 : 783
저장 시간 : 2022-04-04 11:49:35 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 4 월23						월23 수34				(5주 1일)
// 
// 컨테이너 - 다른 객체를 저장하는 객체
//-----------------------------------------------------------------------------

#include <iostream>
#include <array>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// -------
int main()
// -------
{
	save("stl.cpp");

	std::array<int, 10> a{ 0,1,2,3,4,5,6,7,8,9 };

	while (true) {
		int num;
		std::cout << "몇번째 값? ";
		std::cin >> num;

		try {
			std::cout << num << "번째 값은 - " << a.at(num) << std::endl;
		}
		catch (std::exception& e) {
			std::cout << "잘못된 값입니다. " << std::endl;
			std::cout << e.what() << std::endl;
			continue;
		}
	}


} 파일 이름 : stl.cpp, 파일 크기 : 877
저장 시간 : 2022-04-04 12:00:29 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 4 월23						월23 수34				(5주 1일)
// 
// 컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container
//		- array	   유일하게 크기가 컴파일 타임에 결정되어야 함
//		- vector   dynamic array
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <fstream>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// -------
int main()
// -------
{
	// [문제] "stl.cpp"의 char를 v에 저장하라. (공백포함)

	std::ifstream in{ "stl.cpp" };

	std::vector<char> v;
	char c;
	in >> std::noskipws;

	while (in >> c)
		v.push_back(toupper(c));

	std::vector<std::string> v;
	std::string s;
	
	while(in >> s)
		v.push_back(s);

	//std::vector<char> v{ std::istreambuf_iterator<char>{in}, {} };

	for (const auto& data : v)
		std::cout << data;


	save("stl.cpp");
} 파일 이름 : stl.cpp, 파일 크기 : 985
저장 시간 : 2022-04-04 12:20:31 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 4 월23						월23 수34				(5주 1일)
// 
// 컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container
//		- array	   유일하게 크기가 컴파일 타임에 결정되어야 함
//		- vector   dynamic array
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// -------
int main()
// -------
{
	// [문제] 키보드에서 입력하는 모든 단어를 받아라.
	// 오름차순으로 정렬한다
	// 결과를 출력한다

	std::vector<std::string> v;
	std::string str;

	std::cout << "단어를 입력" << std::endl;
	while (std::cin >> str)
		v.push_back(str);
	
	sort(v.begin(), v.end());

	for (const std::string& s : v)
		std::cout << s << std::endl;

	// 저번시간 STRING 코드 문제점 왜 문제였는지 파악하고 알아보기

	save("stl.cpp");
} 파일 이름 : stl.cpp, 파일 크기 : 892
저장 시간 : 2022-04-06 12:09:56 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 6 수34						월23 수34				(5주 2일)
// 
// 컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container - 원소의 순서를 임의 지정 가능
//		- array	   유일하게 크기가 컴파일 타임에 결정되어야 함
//		- vector   dynamic array (실행시간에 크기가 바뀌는 배열)
// 
//  중간시험 예정 - 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// -------
int main()
// -------
{
	std::vector<int> v1;
	std::vector<int> v2;

	if (v1 == v2);
	v2 = v1;

	// std::vector<int>가 제공하는 자료형 - std::vector<int>::value_type;
	// v가 제공하는 함수 멤버			  - v.push_back();
	// 컨테이너간에 적용되는 연산	      - v2 = v1;

	save("stl.cpp");
} 파일 이름 : stl.cpp, 파일 크기 : 1015
저장 시간 : 2022-04-06 12:35:39 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 6 수34						월23 수34				(5주 2일)
// 
// 컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container - 원소의 순서를 임의 지정 가능
//		- array	   유일하게 크기가 컴파일 타임에 결정되어야 함
//		- vector   dynamic array (실행시간에 크기가 바뀌는 배열)
// 
//  중간시험 예정 - 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// -------
int main()
// -------
{
	std::vector v2{ 1,2,3 };		// 초기화리스트에서 형식 연역
	std::vector<int> v { 1, 2, 3  };

	std::cout << "현재 원소수 : " << v.size() << std::endl;
	std::cout << "v가 저장할 수 있는 최대 원소 수 : " << v.max_size() << std::endl;
	// int  - 4611686018427387903
	// char - 9223372036854775807

	std::cout << "벡터 v의 메모리 크기 : " << sizeof(v) << std::endl;


	save("stl.cpp");
} 파일 이름 : stl.cpp, 파일 크기 : 1221
저장 시간 : 2022-04-06 12:51:45 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 6 수34						월23 수34				(5주 2일)
// 
// 컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container - 원소의 순서를 임의 지정 가능
//		- array	   유일하게 크기가 컴파일 타임에 결정되어야 함
//		- vector   dynamic array (실행시간에 크기가 바뀌는 배열)
// 
//  중간시험 예정 - 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// -------
int main()
// -------
{
	save("stl.cpp");
	// [문제] vector의 메모리가 확장되는 모습을 관찰하고 싶다
	// - 원소를 하나씩 추가하면서 벡터가 관리하는 메모리의 크기를 관찰
	// 원소를 추가하며 관찰

	std::vector<int> v{ 1,2,3 };
	
	size_t old_capacity{ v.capacity() };

	while(true){
		v.push_back(4);

		if (v.size() - 1 ==  old_capacity) {
			std::cout << "현재 원소 수 - " << v.size() << std::endl;
			std::cout << "벡터의 용량  - " << v.capacity() << std::endl;
			old_capacity = v.capacity();
			std::cout << std::endl;
		}
	}
	// 수용량을 넘어서 추가하면 수용량을 50% 늘려서 새로운 메모리에 할당함

} 파일 이름 : stl.cpp, 파일 크기 : 946
저장 시간 : 2022-04-06 13:03:18 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 6 수34						월23 수34				(5주 2일)
// 
// 컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container - 원소의 순서를 임의 지정 가능
//		- array	   유일하게 크기가 컴파일 타임에 결정되어야 함
//		- vector   dynamic array (실행시간에 크기가 바뀌는 배열)
// 
//  중간시험 예정 - 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// -------
int main()
// -------
{
	// [문제] 키보드에서 int를 입력받아
	// 합계와 평균을 출력하라
	std::vector<int> v;
	int number;

	while (std::cin >> number) 
		v.push_back(number);

	long long sum{};
	for (int data : v)
		sum += data;

	std::cout << "합 - " << sum << " 평균 - " << double(sum) / v.size() << std::endl;

	save("stl.cpp");
} 파일 이름 : stl.cpp, 파일 크기 : 1425
저장 시간 : 2022-04-06 13:20:34 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 6 수34						월23 수34				(5주 2일)
// 
// 컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container - 원소의 순서를 임의 지정 가능
//		- array	   유일하게 크기가 컴파일 타임에 결정되어야 함
//		- vector   dynamic array (실행시간에 크기가 바뀌는 배열)
// 
//  중간시험 예정 - 4/27(수) (8주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// -------
int main()
// -------
{
	관찰 = true;

	std::vector<STRING> v{"진짜 벡터를 알아본다"};

	v.emplace_back("STRING 추가");

	// 실행시간에 스택에서 메모리를 할당할 수 없다.

	// 먼저 스택에서 임시 객체를 생성한다.
	// 벡터는 이 임시객체를 FreeStore 공간에 복사생성하여 메모리를 할당한다.
	// 벡터는 스택에선 갯수, 수용량, 할당된 객체의 메모리를 담고있다.
	// 벡터가 FreeStore에 할당된 메모리의 정보(주소, 갯수, 수용량)를 Stack에서 저장하였으면 임시객체를 소멸한다.
	// 원소 추가시 수용량을 넘으면 추가할 객체를 임시생성한 것과 기존의 할당된 메모리를 복사하여 연결된 형태의 메모리를 할당한다.
	// 이 작업이 끝나면 예전 할당된 객체와 임시객체를 소멸한다.

	// emplace_back 을 쓰면 추가할때 임시 객체를 생성하지 않는다.


	save("stl.cpp");
} 파일 이름 : stl.cpp, 파일 크기 : 1061
저장 시간 : 2022-04-11 11:26:52 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 11  월23						월23 수34				(6주 1일)
// 
// 컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container - 원소의 순서를 임의 지정 가능
//		- array	   유일하게 크기가 컴파일 타임에 결정되어야 함
//		- vector   dynamic array (실행시간에 크기가 바뀌는 배열)
// 
//  중간시험 예정 - 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// -------
int main()
// -------
{
	관찰 = true;

	std::vector<STRING> v;
	v.reserve(2);
	// 벡터의 capacity를 재설정함
	// 원소갯수를 짐작할 수 있으면 효율적으로 관리 가능

	v.push_back("333");
	v.emplace_back("55555");

	// transaction 문제가 발생하는것을 방지하기 위해
	// 벡터는 수용량을 넘을때 복사생성을 함 -> 효율보단 안정성을 중시함
	// 클래스에서 이동생성/할당 처리 시 noexcept 를 처리하면 이를 무시하고 이동생성/할당 처리를 함

	save("stl.cpp");
} 파일 이름 : stl.cpp, 파일 크기 : 1170
저장 시간 : 2022-04-11 11:31:01 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 11  월23						월23 수34				(6주 1일)
// 
// 컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container - 원소의 순서를 임의 지정 가능
//		- array	   유일하게 크기가 컴파일 타임에 결정되어야 함
//		- vector   dynamic array (실행시간에 크기가 바뀌는 배열)
// 
//  중간시험 예정 - 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// -------
int main()
// -------
{
	//관찰 = true;

	std::vector<STRING> v{ "1", "333", "55555" , "22", "44444"};

	for (const auto& data : v)
		std::cout << data << " ";
	std::cout << std::endl;

	// [문제] 길이 오름차순 정렬 후 출력

	관찰 = true;
	sort(v.begin(), v.end(), [](const STRING& a, const STRING& b) {
		return a.getNum() < b.getNum();
		});
	관찰 = false;
	// 이동생성/할당 을 처리하면 sort를 효율적으로 처리할 수 있음

	for (const auto& data : v)
		std::cout << data << " ";
	std::cout << std::endl;


	save("stl.cpp");
} 파일 이름 : stl.cpp, 파일 크기 : 1137
저장 시간 : 2022-04-11 12:03:52 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 11  월23						월23 수34				(6주 1일)
// 
// 컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container - 원소의 순서를 임의 지정 가능
//		- array	   유일하게 크기가 컴파일 타임에 결정되어야 함
//		- vector   dynamic array (실행시간에 크기가 바뀌는 배열)
// 
//  STRING 클래스 이동지원 - 자원을 관리하는 클래스는 이동문법을 지원해야 함
//		내가 사용하는 것이 아니라 컨테이너/알고리즘에서 사용
// 
//  클래스의 멤버 변수가 private이 아니라면 ???
// 
//  중간시험 예정 - 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include <algorithm>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// -------
int main()
// -------
{
	std::vector<int> v{ 1,2,3,4,5,6,7,8,9,10 };

	// [문제] 짝수를 제거하고 출력하라
	
	auto p = std::remove_if(v.begin(), v.end(), [](int n) {
		return (n % 2) == 0;
		});

	v.erase(p, v.end());

	for (int n : v)
		std::cout << n << " ";
	std::cout << std::endl;

	save("stl.cpp");
} 파일 이름 : stl.cpp, 파일 크기 : 1433
저장 시간 : 2022-04-11 12:19:32 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 11  월23						월23 수34				(6주 1일)
// 
// 컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container - 원소의 순서를 임의 지정 가능
//		- array	   유일하게 크기가 컴파일 타임에 결정되어야 함
//		- vector   dynamic array (실행시간에 크기가 바뀌는 배열)
// 
//  STRING 클래스 이동지원 - 자원을 관리하는 클래스는 이동문법을 지원해야 함
//		내가 사용하는 것이 아니라 컨테이너/알고리즘에서 사용
// 
//  클래스의 멤버 변수가 private이 아니라면 ???
// 
//  중간시험 예정 - 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <string>
#include <algorithm>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// -------
int main()
// -------
{
	// [문제] "소스.cpp" 를 읽어 알파벳의 갯수를 다음과 같이 출력하라.
	// 대소문자를 구분하진 않는다.

	// [a] - 10
	// [b] - 2
	//  ...
	// [z] - 1

	int alpha_count[26] = {};

	std::ifstream in("stl.cpp");

	std::string s;

	if (in.is_open()) {
		in.seekg(0, std::ios::end);
		int size = in.tellg();

		s.resize(size);
		in.seekg(0, std::ios::beg);

		in.read(&s[0], size);
	}
	
	
	for (int i = 0; i < s.size(); ++i) {
		if ((s[i] >= 'a' && s[i] <= 'z')) {
			
		}
		else if (s[i] >= 'A' && s[i] <= 'Z') {

		}
	}


	 save("stl.cpp");
} 파일 이름 : stl.cpp, 파일 크기 : 1383
저장 시간 : 2022-04-11 21:56:47 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 11  월23						월23 수34				(6주 1일)
// 
// 컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container - 원소의 순서를 임의 지정 가능
//		- array	   유일하게 크기가 컴파일 타임에 결정되어야 함
//		- vector   dynamic array (실행시간에 크기가 바뀌는 배열)
// 
//  STRING 클래스 이동지원 - 자원을 관리하는 클래스는 이동문법을 지원해야 함
//		내가 사용하는 것이 아니라 컨테이너/알고리즘에서 사용
// 
//  클래스의 멤버 변수가 private이 아니라면 ???
// 
//  중간시험 예정 - 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// -------
int main()
// -------
{
	// [문제] "소스.cpp" 를 읽어 알파벳의 갯수를 다음과 같이 출력하라.
	// 대소문자를 구분하진 않는다.

	// [a] - 10
	// [b] - 2
	//  ...
	// [z] - 1

	int alphabet_count[26] = {};

	std::ifstream in("stl.cpp");

	char c;
	while (in >> c) {
		if (islower(c)) 
			alphabet_count[c - 'a'] += 1;

		 else if (isupper(c)) 
			alphabet_count[c - 'A'] += 1;
			
	}

	for (int i{}; i < sizeof(alphabet_count) / sizeof(alphabet_count[0]); ++i) {
		std::cout << (char)('a' + i) << " : " << alphabet_count[i] << std::endl;
	}


	 save("stl.cpp");
} 파일 이름 : stl.cpp, 파일 크기 : 1116
저장 시간 : 2022-04-13 11:36:13 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 13  수34						월23 수34				(6주 2일)
// 
// 컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container - 원소의 순서를 임의 지정 가능
//		- array	   유일하게 크기가 컴파일 타임에 결정되어야 함
//		- vector   dynamic array (실행시간에 크기가 바뀌는 배열)
// 
//  중간시험 예정 - 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <fstream>
#include <array>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// -------
int main()
// -------
{
	// [문제] "소스.cpp" 를 읽어 알파벳의 갯수를 다음과 같이 출력하라.
	// 대소문자를 구분하진 않는다.

	// [a] - 10
	// [b] - 2
	//  ...
	// [z] - 1

	std::array<int, 26> alphabet_count{};

	std::ifstream in("stl.cpp");

	char c;
	while (in >> c)
		if (isalpha(c))
			alphabet_count[tolower(c) - 'a']++;

	for (int i{}; i < alphabet_count.size(); ++i) 
		std::cout << static_cast<char>('a' + i) << " - " << alphabet_count[i] << std::endl;


	 save("stl.cpp");
} 파일 이름 : stl.cpp, 파일 크기 : 1071
저장 시간 : 2022-04-13 12:04:31 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 13  수34						월23 수34				(6주 2일)
// 
// 컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container - 원소의 순서를 임의 지정 가능
//		- array	   유일하게 크기가 컴파일 타임에 결정되어야 함
//		- vector   dynamic array (실행시간에 크기가 바뀌는 배열)
// 
//  중간시험 예정 - 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <vector>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// -------
int main()
// -------
{
	std::vector<STRING> v{ "1", "22", "4444", "55555" };

	// [문제] 세번째 원소 STRING("333")을 끼워넣고 전체를 출력하라

	관찰 = true;
	v.insert(v.cbegin() + 2, "333");
	관찰 = false;

	for (const auto& data : v)
		std::cout << data << std::endl;
	
	// 위의 코드는 매우 비효율적으로 작동함

	// 메모리가 연속적인 컨테이너
	// POD T[]
	// array<T, N>
	// vector
	// string
	// 이를 c++에서 span 이라고 함


	 save("stl.cpp");
} 파일 이름 : stl.cpp, 파일 크기 : 1065
저장 시간 : 2022-04-13 12:32:41 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 13  수34						월23 수34				(6주 2일)
// 
// 컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container - 원소의 순서를 임의 지정 가능
//		- array	   유일하게 크기가 컴파일 타임에 결정되어야 함
//		- vector   dynamic array (실행시간에 크기가 바뀌는 배열)
//		- deque	   벡터와 리스트의 중간단계 (블럭단위로 여러 객체를 감싸고, 블럭의 한도를 초과했을때 객체 추가시 리스트처럼 블럭을 추가함)
//	
// Associative Container
// Unordered Associative Container
// 
//  중간시험 예정 - 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <deque>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// -------
int main()
// -------
{
	std::deque<STRING> d{ "1", "22", "333", "4444", "55555" };

	d.push_front("-333");

	for (int i = 0; i < d.size(); ++i)
		std::cout << d[i] << std::endl;
	// 인덱스가 블럭단위를 넘으면 포인터를 타고 넘어감


	 save("stl.cpp");
} 파일 이름 : stl.cpp, 파일 크기 : 1358
저장 시간 : 2022-04-13 12:44:05 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 13  수34						월23 수34				(6주 2일)
// 
// 컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container - 원소의 순서를 임의 지정 가능
//		- array	   유일하게 크기가 컴파일 타임에 결정되어야 함
//		- vector   dynamic array (실행시간에 크기가 바뀌는 배열)
//		- deque	   벡터와 리스트의 중간단계 (블럭단위로 여러 객체를 감싸고, 블럭의 한도를 초과했을때 객체 추가시 리스트처럼 블럭을 추가함)
//	
// Associative Container
// Unordered Associative Container
// 
//  중간시험 예정 - 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <deque>
#include <vector>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

class Test {
	int n;

public:
	void show() const {
		std::cout << "메모리 번지 - " << this << std::endl;
	}
};


// -------
int main()
// -------
{
	// [확인] vector와 deque의 메모리 연속성
	// vector는 연속적, deque는 연속적인 것처럼 보임
	// deque에서 메모리의 크기가 블럭단위를 넘으면 블럭을 하나 생성함
	// 랜덤 액세스의 경우 vector 가 deque 보다 약간 성능이 좋음

	// std::vector<Test> v(10);
	std::deque<Test> v(10);
	
	v.push_front(Test{});
	for (int i = 0; i < v.size(); ++i)
		v[i].show();




	save("stl.cpp");
} 파일 이름 : stl.cpp, 파일 크기 : 1218
저장 시간 : 2022-04-13 12:57:18 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 13  수34						월23 수34				(6주 2일)
// 
// 컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container - 원소의 순서를 임의 지정 가능
//		- array	   유일하게 크기가 컴파일 타임에 결정되어야 함
//		- vector   dynamic array (실행시간에 크기가 바뀌는 배열)
//		- deque	   벡터와 리스트의 중간단계, Contiguous Container가 아니다. 
//				   (블럭단위로 여러 객체를 감싸고, 블럭의 한도를 초과했을때 객체 추가시 리스트처럼 블럭을 추가함)
//	
// Associative Container
// Unordered Associative Container
// 
//  중간시험 예정 - 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <deque>
#include <vector>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// -------
int main()
// -------
{
	save("stl.cpp");

	// [확인] deque이 vector 보다 원소를 더 많이 저장할 수 있다고?
	// 벡터 - 136216567
	// 덱 - 268435452

	std::deque<int> v;
	while (true) {
		try {
			v.push_back(1);
		}
		catch (std::exception& e) {
			std::cout << "현재 v 의 원소 갯수 - " << v.size() << std::endl;
			return 0;
		}
	}

	
} 파일 이름 : stl.cpp, 파일 크기 : 1329
저장 시간 : 2022-04-13 13:20:26 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 13  수34						월23 수34				(6주 2일)
// 
// 컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container - 원소의 순서를 임의 지정 가능
//		- array	   유일하게 크기가 컴파일 타임에 결정되어야 함
//		- vector   dynamic array (실행시간에 크기가 바뀌는 배열)
//		- deque	   벡터와 리스트의 중간단계, Contiguous Container가 아니다. 
//				   벡터보다 더 많은 원소를 저장할 수 있다.
//	
// Associative Container
// Unordered Associative Container
// 
//  중간시험 예정 - 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <deque>
#include <string>
#include <algorithm>
#include <fstream>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// [문제] "stl.cpp" 파일의 단어를 deque<string>에 저장하라.
// 길이 오름차순으로 정렬하라
// 정렬된 결과를 출력하라

// -------
int main()
// -------
{
	std::ifstream in("stl.cpp");

	std::deque<std::string> d;

	std::string s;
	while (in >> s)
		d.push_back(s);
	
	sort(d.begin(), d.end(), [](const std::string& a, const std::string& b) {
		return a.size() < b.size();
		});

	for (int i = 0; i < d.size(); ++i) 
		std::cout << d[i] << std::endl;
	
	save("stl.cpp");
} 파일 이름 : stl.cpp, 파일 크기 : 1386
저장 시간 : 2022-04-18 11:01:16 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 18  월23						월23 수34				(7주 1일)
// 
// 컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container - 원소의 순서를 임의 지정 가능
//		- array	   유일하게 크기가 컴파일 타임에 결정되어야 함
//		- vector   dynamic array (실행시간에 크기가 바뀌는 배열)
//				   벡터의 크기가 변경될 때 반복자가 무효화 될 수 있다(iterator invalidation)
//		- deque	   벡터와 리스트의 중간단계, Contiguous Container가 아니다. 
//				   벡터보다 더 많은 원소를 저장할 수 있다.
//				   반복자가 무효화되지 않는다.
// 
// Associative Container
// Unordered Associative Container
// 
//  중간시험 예정 - 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <deque>
#include <string>
#include <algorithm>
#include <fstream>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// [문제] "stl.cpp" 파일의 단어를 deque<string>에 저장하라.
// 내림차순으로 정렬하라.
// 정렬된 결과를 출력하라

// -------
int main()
// -------
{
	std::ifstream in("stl.cpp");

	std::deque<std::string> d;

	std::string s;
	while (in >> s)
		d.push_back(s);
	
	sort(d.begin(), d.end(), std::greater<std::string>());

	for (const std::string& s : d)
		std::cout << s << std::endl;
	


	save("stl.cpp");
} 파일 이름 : stl.cpp, 파일 크기 : 1556
저장 시간 : 2022-04-18 11:06:42 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 18  월23						월23 수34				(7주 1일)
// 
// 컨테이너 - 다른 객체를 저장하는 객체
// Sequence Container - 원소의 순서를 임의 지정 가능
//		- array	   유일하게 크기가 컴파일 타임에 결정되어야 함
//		- vector   dynamic array (실행시간에 크기가 바뀌는 배열)
//				   벡터의 크기가 변경될 때 반복자가 무효화 될 수 있다(iterator invalidation)
//		- deque	   벡터와 리스트의 중간단계, Contiguous Container가 아니다. 
//				   벡터보다 더 많은 원소를 저장할 수 있다.
//				   반복자가 무효화되지 않는다.
// 
// Associative Container
// Unordered Associative Container
// 
//  중간시험 예정 - 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <deque>
#include <string>
#include <algorithm>
#include <fstream>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// [문제] "stl.cpp" 파일의 단어를 deque<string>에 저장하라.
// 내림차순으로 정렬하라.
// 정렬된 결과를 출력하라

// -------
int main()
// -------
{
	std::ifstream in("stl.cpp");

	std::deque<std::string> d{ std::istream_iterator<std::string>{in}, {} };
	// in파일에서 <string>을 읽는데 {} 까지 ( 읽을곳이 없을때 까지)

	sort(d.begin(), d.end(), std::greater<std::string>());

	
	std::copy(d.begin(), d.end(), std::ostream_iterator<std::string>{std::cout, "\n"});
	// 덱의 시작부터 끝까지 outstream으로 복사, osream은 <string> 이며 목표는 cout, 구분자는 \n


	save("stl.cpp");
} 파일 이름 : stl.cpp, 파일 크기 : 1773
저장 시간 : 2022-04-18 11:15:37 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 18  월23						월23 수34				(7주 1일)
// 
// 컨테이너 - 다른 객체를 저장하는 객체
// 
// STL contiguous containers - T[], array<T,N>, vector<T>, string
// 
// Sequence Container - 원소의 순서를 임의 지정 가능
//		- array	   유일하게 크기가 컴파일 타임에 결정되어야 함
//		- vector   dynamic array (실행시간에 크기가 바뀌는 배열)
//				   벡터의 크기가 변경될 때 반복자가 무효화 될 수 있다(iterator invalidation)
//		- deque	   벡터와 리스트의 중간단계, Contiguous Container가 아니다. 
//				   벡터보다 더 많은 원소를 저장할 수 있다.
//				   반복자가 무효화되지 않는다.
// 
// Associative Container
// Unordered Associative Container
// 
//  중간시험 예정 - 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <deque>
#include <string>
#include <algorithm>
#include <fstream>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// [문제] "Test.txt" 파일의 단어를 deque<string>에 저장하라.
// 내림차순으로 정렬하라.
// 각 단어를 오름차순으로 정렬하라.
// 정렬된 결과를 출력하라

// -------
int main()
// -------
{
	std::ifstream in("Test.txt");

	std::deque<std::string> d{ std::istream_iterator<std::string>{in}, {} };
	// in파일에서 <string>을 읽는데 {} 까지 ( 읽을곳이 없을때 까지)

	sort(d.begin(), d.end(), std::greater<std::string>());

	// 각 단어를 오름차순(ascending order) 정렬
	for (std::string& s : d)
		sort(s.begin(), s.end());

	std::copy(d.begin(), d.end(), std::ostream_iterator<std::string>{std::cout, "\n"});
	// 덱의 시작부터 끝까지 outstream으로 복사, osream은 <string> 이며 목표는 cout, 구분자는 \n


	save("stl.cpp");
} 파일 이름 : stl.cpp, 파일 크기 : 1687
저장 시간 : 2022-04-18 11:37:40 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 18  월23						월23 수34				(7주 1일)
// 
// 컨테이너 - 다른 객체를 저장하는 객체
// 
// STL contiguous containers - T[], array<T,N>, vector<T>, string
// 
// Sequence Container - 원소의 순서를 임의 지정 가능
//		- array	   유일하게 크기가 컴파일 타임에 결정되어야 함
//		- vector   dynamic array (실행시간에 크기가 바뀌는 배열)
//				   벡터의 크기가 변경될 때 반복자가 무효화 될 수 있다(iterator invalidation)
//		- deque	   벡터와 리스트의 중간단계, Contiguous Container가 아니다. 
//				   벡터보다 더 많은 원소를 저장할 수 있다.
//				   반복자가 무효화되지 않는다.
// 
// Associative Container
// Unordered Associative Container
// 
//  중간시험 예정 - 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <deque>
#include <string>
#include <algorithm>
#include <fstream>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// [문제] "Test.txt" 파일의 단어를 deque<string>에 저장하라.
// 내림차순으로 정렬하라.
// 각 단어를 오름차순으로 정렬하라.
// 정렬된 결과를 출력하라

// -------
int main()
// -------
{
	std::ifstream in("Test.txt");

	std::deque<std::string> d;
	std::string str;

	while (in >> str)
		d.push_back(str);

	// [문제] library는 3번째 단어이다. 
	// space라는 단어를 찾아라. 있다면 몇 번째 단어인가?


	auto it = std::find(d.begin(), d.end(), "space");

	if (it != d.end()) 
		std::cout << it - d.begin() + 1 << " 번째 단어입니다." << std::endl;
	else
		std::cout << "찾는 단어가 없습니다. " << std::endl;
	
	save("stl.cpp");
} 파일 이름 : stl.cpp, 파일 크기 : 1834
저장 시간 : 2022-04-18 11:49:50 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 18  월23						월23 수34				(7주 1일)
// 
// 컨테이너 - 다른 객체를 저장하는 객체
// 
// STL contiguous containers - T[], array<T,N>, vector<T>, string
// 
// Sequence Container - 원소의 순서를 임의 지정 가능
//		- array	   유일하게 크기가 컴파일 타임에 결정되어야 함
//		- vector   dynamic array (실행시간에 크기가 바뀌는 배열)
//				   벡터의 크기가 변경될 때 반복자가 무효화 될 수 있다(iterator invalidation)
//		- deque	   벡터와 리스트의 중간단계, Contiguous Container가 아니다. 
//				   벡터보다 더 많은 원소를 저장할 수 있다.
//				   반복자가 무효화되지 않는다.
//		- list 
// 
// Associative Container
// Unordered Associative Container
// 
//  중간시험 예정 - 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <deque>
#include <list>
#include <string>
#include <algorithm>
#include <fstream>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// [문제] "Test.txt" 파일의 단어를 deque<string>에 저장하라.
// 내림차순으로 정렬하라.
// 각 단어를 오름차순으로 정렬하라.
// 정렬된 결과를 출력하라

// -------
int main()
// -------
{
	std::ifstream in("Test.txt");

	std::list<std::string> cont;
	std::string str;

	while (in >> str)
		cont.push_back(str);

	for (const std::string& s : cont)
		std::cout << s << std::endl;
	// cont[i] 와같은 [] 연산자는 사용할 수 없다.

	// [문제] space는 몇번째 단어인지 출력하라

	auto it = std::find(cont.begin(), cont.end(), "space");
	
	if (it == cont.end()) 
		std::cout << "없는 단어입니다. " << std::endl;
	else {
		int idx = std::distance(it, cont.begin());
		std::cout << idx + 1 << "번째 단어입니다. " << std::endl;
	}

	save("stl.cpp");
} 파일 이름 : stl.cpp, 파일 크기 : 2131
저장 시간 : 2022-04-18 11:58:48 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 18  월23						월23 수34				(7주 1일)
// 
// 컨테이너 - 다른 객체를 저장하는 객체
// 
// STL contiguous containers - T[], array<T,N>, vector<T>, string
// 
// Sequence Container - 원소의 순서를 임의 지정 가능
//		- array	   유일하게 크기가 컴파일 타임에 결정되어야 함
//		- vector   dynamic array (실행시간에 크기가 바뀌는 배열)
//				   벡터의 크기가 변경될 때 반복자가 무효화 될 수 있다(iterator invalidation)
//		- deque	   벡터와 리스트의 중간단계, Contiguous Container가 아니다. 
//				   벡터보다 더 많은 원소를 저장할 수 있다.
//				   반복자가 무효화되지 않는다.
//		- list 
// 
// Associative Container
// Unordered Associative Container
// 
//  중간시험 예정 - 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <deque>
#include <list>
#include <string>
#include <algorithm>
#include <fstream>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// [문제] "Test.txt" 파일의 단어를 deque<string>에 저장하라.
// 내림차순으로 정렬하라.
// 각 단어를 오름차순으로 정렬하라.
// 정렬된 결과를 출력하라

// -------
int main()
// -------
{
	std::ifstream in("Test.txt");

	std::list<std::string> cont;
	std::string str;

	while (in >> str)
		cont.push_back(str);

	// [문제] space는 몇번째 단어인지 출력하라

	auto it = std::find(cont.begin(), cont.end(), "space");

	if (it == cont.end())
		std::cout << "없는 단어입니다." << std::endl;
	else
		std::cout << std::distance(cont.begin(), it) + 1 << "번째 단어입니다." << std::endl;


	/*int step{};
	auto beg = cont.begin();

	while (true) {
		if (beg == it) {
			break;
		}
		else {
			++beg;
			++step;
		}
	}
	std::cout << step + 1 << "번째 원소입니다." << std::endl;*/

	//int cnt{};
	//if (it == cont.end()) 
	//	std::cout << "없는 단어입니다. " << std::endl;
	//else {
	//	for (auto p = cont.begin(); p != it; ++p)
	//		++cnt;

	//	std::cout << cnt + 1 << "번째 단어입니다." << std::endl;
	//}

	save("stl.cpp");
} 파일 이름 : stl.cpp, 파일 크기 : 1768
저장 시간 : 2022-04-18 12:08:37 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 18  월23						월23 수34				(7주 1일)
// 
// 컨테이너 - 다른 객체를 저장하는 객체
// 
// STL contiguous containers - T[], array<T,N>, vector<T>, string
// 
// Sequence Container - 원소의 순서를 임의 지정 가능
//		- array	   유일하게 크기가 컴파일 타임에 결정되어야 함
//		- vector   dynamic array (실행시간에 크기가 바뀌는 배열)
//				   벡터의 크기가 변경될 때 반복자가 무효화 될 수 있다(iterator invalidation)
//		- deque	   벡터와 리스트의 중간단계, Contiguous Container가 아니다. 
//				   벡터보다 더 많은 원소를 저장할 수 있다.
//				   반복자가 무효화되지 않는다.
//		- list 
// 
// Associative Container
// Unordered Associative Container
// 
//  중간시험 예정 - 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <deque>
#include <list>
#include <string>
#include <algorithm>
#include <fstream>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// [문제] "Test.txt" 파일의 단어를 deque<string>에 저장하라.
// 내림차순으로 정렬하라.
// 각 단어를 오름차순으로 정렬하라.
// 정렬된 결과를 출력하라

// -------
int main()
// -------
{
	std::ifstream in("Test.txt");

	std::list<std::string> cont;
	std::string str;

	while (in >> str)
		cont.push_back(str);

	// [문제] cont를 ascending order(오름차순)로 정렬하라.

	cont.sort();

	// [문제] space는 몇번째 단어인지 출력하라

	auto it = std::find(cont.begin(), cont.end(), "space");

	if (it == cont.end())
		std::cout << "없는 단어입니다." << std::endl;
	else
		std::cout << std::distance(cont.begin(), it) + 1 << "번째 단어입니다." << std::endl;



	save("stl.cpp");
} 파일 이름 : stl.cpp, 파일 크기 : 1762
저장 시간 : 2022-04-18 12:14:15 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 18  월23						월23 수34				(7주 1일)
// 
// 컨테이너 - 다른 객체를 저장하는 객체
// 
// STL contiguous containers - T[], array<T,N>, vector<T>, string
// 
// Sequence Container - 원소의 순서를 임의 지정 가능
//		- array	   유일하게 크기가 컴파일 타임에 결정되어야 함
//		- vector   dynamic array (실행시간에 크기가 바뀌는 배열)
//				   벡터의 크기가 변경될 때 반복자가 무효화 될 수 있다(iterator invalidation)
//		- deque	   벡터와 리스트의 중간단계, Contiguous Container가 아니다. 
//				   벡터보다 더 많은 원소를 저장할 수 있다.
//				   반복자가 무효화되지 않는다.
//		- list 
// 
// Associative Container
// Unordered Associative Container
// 
//  중간시험 예정 - 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <deque>
#include <list>
#include <string>
#include <algorithm>
#include <fstream>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// [문제] "Test.txt" 파일의 단어를 deque<string>에 저장하라.
// 내림차순으로 정렬하라.
// 각 단어를 오름차순으로 정렬하라.
// 정렬된 결과를 출력하라

// -------
int main()
// -------
{
	std::ifstream in("Test.txt");

	std::list<std::string> cont;
	std::string str;

	while (in >> str)
		cont.push_back(str);

	// [문제] cont를 ascending order(오름차순)로 정렬하라.

	cont.sort();

	// [문제] 앞에서부터 10개만 화면에 출력하라.
	/*auto p{ cont.begin() };
	for (int i = 0; i < 10; ++i)
		std::cout << *p++ << std::endl;*/

	// 뒤에서부터 10개만 출력하라.

	auto p = cont.rbegin();
	for (int i = 0; i < 10; ++i)
		std::cout << *p++ << std::endl;
	
	save("stl.cpp");
} 파일 이름 : stl.cpp, 파일 크기 : 1695
저장 시간 : 2022-04-18 12:18:20 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 18  월23						월23 수34				(7주 1일)
// 
// 컨테이너 - 다른 객체를 저장하는 객체
// 
// STL contiguous containers - T[], array<T,N>, vector<T>, string
// 
// Sequence Container - 원소의 순서를 임의 지정 가능
//		- array	   유일하게 크기가 컴파일 타임에 결정되어야 함
//		- vector   dynamic array (실행시간에 크기가 바뀌는 배열)
//				   벡터의 크기가 변경될 때 반복자가 무효화 될 수 있다(iterator invalidation)
//		- deque	   벡터와 리스트의 중간단계, Contiguous Container가 아니다. 
//				   벡터보다 더 많은 원소를 저장할 수 있다.
//				   반복자가 무효화되지 않는다.
//		- list 
// 
// Associative Container
// Unordered Associative Container
// 
//  중간시험 예정 - 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <deque>
#include <list>
#include <string>
#include <algorithm>
#include <fstream>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// [문제] "Test.txt" 파일의 단어를 deque<string>에 저장하라.
// 내림차순으로 정렬하라.
// 각 단어를 오름차순으로 정렬하라.
// 정렬된 결과를 출력하라

// -------
int main()
// -------
{
	std::ifstream in("Test.txt");

	std::list<std::string> cont;
	std::string str;

	while (in >> str)
		cont.push_back(str);

	// [문제] cont를 ascending order(오름차순)로 정렬하라.

	cont.sort();

	// [문제] 글자수가 5개인 것만 화면에 출력하라
	

	std::copy_if(cont.begin(), cont.end(), std::ostream_iterator<std::string>{std::cout, "\n"}, [](const std::string& a) {
		return a.size() == 5;
		});

	save("stl.cpp");
} 파일 이름 : stl.cpp, 파일 크기 : 1889
저장 시간 : 2022-04-18 12:20:54 GMT+9

//-----------------------------------------------------------------------------
// 2022. 4. 18  월23						월23 수34				(7주 1일)
// 
// 컨테이너 - 다른 객체를 저장하는 객체
// 
// STL contiguous containers - T[], array<T,N>, vector<T>, string
// 
// Sequence Container - 원소의 순서를 임의 지정 가능
//		- array	   유일하게 크기가 컴파일 타임에 결정되어야 함
//		- vector   dynamic array (실행시간에 크기가 바뀌는 배열)
//				   벡터의 크기가 변경될 때 반복자가 무효화 될 수 있다(iterator invalidation)
//		- deque	   벡터와 리스트의 중간단계, Contiguous Container가 아니다. 
//				   벡터보다 더 많은 원소를 저장할 수 있다.
//				   반복자가 무효화되지 않는다.
//		- list 
// 
// Associative Container
// Unordered Associative Container
// 
//  중간시험 예정 - 4/20(수) (7주 2일)
//-----------------------------------------------------------------------------

#include <iostream>
#include <deque>
#include <list>
#include <string>
#include <algorithm>
#include <fstream>
#include "save.h"
#include "STRING.h"

extern bool 관찰;

// [문제] "Test.txt" 파일의 단어를 deque<string>에 저장하라.
// 내림차순으로 정렬하라.
// 각 단어를 오름차순으로 정렬하라.
// 정렬된 결과를 출력하라

// -------
int main()
// -------
{
	std::ifstream in("Test.txt");

	std::list<std::string> cont;
	std::string str;

	while (in >> str)
		cont.push_back(str);

	// [문제] cont를 ascending order(오름차순)로 정렬하라.

	cont.sort();

	// [문제] 글자수가 5개인 것만 화면에 출력하라
	

	std::copy_if(cont.begin(), cont.end(), std::ostream_iterator<std::string>{std::cout, "\n"}, [](const std::string& a) {
		return a.size() == 5;
		});

	// 글자수 5개 카운트

	int num = std::count_if(cont.begin(), cont.end(), [](const std::string& a) {
		return a.size() == 5;
		});

	std::cout << "5개의 글자수는 " << num << std::endl;

	save("stl.cpp");
} 